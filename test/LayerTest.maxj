import org.junit.Test;
import java.util.List;
import java.util.ArrayList;
import java.lang.Math;

import com.maxeler.maxcompiler.v2.kernelcompiler.Kernel;
import com.maxeler.maxcompiler.v2.kernelcompiler.KernelParameters;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.managers.standard.SimulationManager;
import com.maxeler.maxcompiler.v2.utils.Bits;

public class LayerTest {

    private final char      AcFunc = 't';
    private final int   InBlockDim = 2;
    private final int  NumInBlocks = 4;
    private final int  OutBlockDim = 16;
    private final int NumOutBlocks = 4;


    private class LayerTestKernel extends Kernel {

        LayerTestKernel(KernelParameters parameters)
        {

        super(parameters);

        // Counters
        // Remarks - AddrGenerator cannot be reset at Tick 0, so postpone 1 cycle
        DFEVar Tick = control.count.simpleCounter(32);
        DFEVar beginFwdProp = (Tick === 1);
        AddrGenerator ComputingCounter = new AddrGenerator(this, 1, 32, beginFwdProp);
        DFEVar isCalculating = ComputingCounter.isValid();

        // Inputs
        DFEVectorType<DFEVar> InVecType = new DFEVectorType<DFEVar>(Def.DataType, NumInBlocks);
        DFEVector<DFEVar>   PrevLayer = io.input("PrevLayer",   InVecType, isCalculating);
        DFEVector<DFEVar> PrevRyLayer = io.input("PrevRyLayer", InVecType, isCalculating);        

        // Layer Block
        Layer TestLayer = new Layer(this, 0, AcFunc, InBlockDim, NumInBlocks, OutBlockDim, NumOutBlocks,
                                    PrevLayer, PrevRyLayer, beginFwdProp);

        }
    }

    @Test 
    public void testRandomInputData() {
    
        // Settings
        final int numTicks = 50;
        final int  InLayerSize =  InBlockDim * NumInBlocks;
        final int OutLayerSize = OutBlockDim * NumOutBlocks;
        final int   NumWeights = InLayerSize * OutLayerSize;
        
        // Kernel
        SimulationManager  mgr = new SimulationManager("LayerTest");
        LayerTestKernel kernel = new LayerTestKernel(mgr.makeKernelParameters());
        mgr.setKernel(kernel);

        // Assign Random Weight and VWeight
        double []  W = new double[NumWeights];
        double [] VW = new double[NumWeights];
        for (int i=0; i<NumWeights; ++i) {
             W[i] = Math.random();
            VW[i] = Math.random();
        }
        for (int X=0; X<NumInBlocks; ++X) {
            for (int Y=0; Y<NumOutBlocks; ++Y) {
                int addr = 0;
                for (int addrX=0; addrX<InBlockDim; ++addrX) {
                    for (int addrY=0; addrY<OutBlockDim; ++addrY) {               
                        double curW  =  W[(X*InBlockDim+addrX)*OutLayerSize + Y*OutBlockDim + addrY];
                        double curVW = VW[(X*InBlockDim+addrX)*OutLayerSize + Y*OutBlockDim + addrY];
                        mgr.setMappedRom("W0"+"X"+X+"Y"+Y,  addr, curW);
                        mgr.setMappedRom("VW0"+"X"+X+"Y"+Y, addr, curVW);
                        addr++;
                    }
                }
            }
        }
        
        // Assign Random Bias and VBias
        double []  B = new double[OutLayerSize];
        double [] VB = new double[OutLayerSize];
        for (int i=0; i<OutLayerSize; ++i) {
             B[i] = Math.random();
            VB[i] = Math.random();
        }
        for (int Y=0; Y<NumOutBlocks; ++Y) {
            for (int addrY=0; addrY<OutBlockDim; ++addrY) {
                mgr.setMappedRom("B0"+"Y"+Y,  addrY,  B[Y*OutBlockDim + addrY]);
                mgr.setMappedRom("VB0"+"Y"+Y, addrY, VB[Y*OutBlockDim + addrY]);
            }
        }

        // Feed Random PrevLayer and PrevRyLayer
        double []  y = new double[InLayerSize];
        double [] Ry = new double[InLayerSize];
        for (int i=0; i<InLayerSize; ++i) {
             y[i] = Math.random();
            Ry[i] = Math.random();
        }
        double [][] PrevLayerData   = new double[InBlockDim*OutBlockDim][NumInBlocks];
        double [][] PrevRyLayerData = new double[InBlockDim*OutBlockDim][NumInBlocks];
        for (int i=0; i<OutBlockDim; ++i) {
            for (int j=0; j<InBlockDim; ++j) {
                int iter = i * InBlockDim + j;
                for (int k=0; k<NumInBlocks; ++k) {
                      PrevLayerData[iter][k] =  y[k*InBlockDim+j];
                    PrevRyLayerData[iter][k] = Ry[k*InBlockDim+j];
                }
            }
        }
        List<Bits> PrevLayer   = VectorDataGenerator(PrevLayerData,   InBlockDim*OutBlockDim, NumInBlocks);
        List<Bits> PrevRyLayer = VectorDataGenerator(PrevRyLayerData, InBlockDim*OutBlockDim, NumInBlocks);
        mgr.setInputDataRaw("PrevLayer", PrevLayer);
        mgr.setInputDataRaw("PrevRyLayer", PrevRyLayer);

        // Calculate Expected Output
        for (int iter=0; iter<OutBlockDim; ++iter) {
            double []  ExpectedY = new double[NumOutBlocks];
            double [] ExpectedRy = new double[NumOutBlocks];
            for (int Y=0; Y<NumOutBlocks; ++Y) {
                 ExpectedY[Y] =  B[Y*OutBlockDim + iter];
                ExpectedRy[Y] = VB[Y*OutBlockDim + iter];
                for (int row=0; row<InLayerSize; ++row) {
                     ExpectedY[Y] +=  W[row*OutLayerSize + Y*OutBlockDim + iter] *  y[row];
                    ExpectedRy[Y] +=  W[row*OutLayerSize + Y*OutBlockDim + iter] * Ry[row];
                    ExpectedRy[Y] += VW[row*OutLayerSize + Y*OutBlockDim + iter] *  y[row];
                }
                 ExpectedY[Y] = Math.tanh(ExpectedY[Y]);
                ExpectedRy[Y] = ExpectedRy[Y] * (1 - ExpectedY[Y] * ExpectedY[Y]);
            }
            System.out.println("Iter["+iter+"] Y=("+ExpectedY[0]+","+ExpectedY[1]+","+ExpectedY[2]+","+ExpectedY[3]+"), "
                                         + "Ry=("+ExpectedRy[0]+","+ExpectedRy[1]+","+ExpectedRy[2]+","+ExpectedRy[3]+")");
        }

        // Run Test
        mgr.setKernelCycles(numTicks);
        mgr.runTest();

    }
    
    // Input Data Generator
    public static List<Bits> VectorDataGenerator(double [][] data, int VectorDepth, int VectorWidth) {
        final List<Bits> encodedData = new ArrayList<Bits>(VectorDepth);
        for (int i=0; i<VectorDepth; ++i) {
            Bits thisStepBits = Def.DataType.encodeConstant(data[i][0]);
            for (int j=1; j<VectorWidth; ++j){
                thisStepBits = Def.DataType.encodeConstant(data[i][j]).cat(thisStepBits);
            }
            encodedData.add(thisStepBits);
        }
        return encodedData;
    }
}
