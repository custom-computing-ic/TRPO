import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.BuildConfig;
import com.maxeler.maxcompiler.v2.managers.DFEArchitecture;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface.Direction;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;
import com.maxeler.maxcompiler.v2.build.EngineParameters;

public class TRPOManager extends CustomManager{

    private static final String Name  = "TRPOKernel";


    TRPOManager(EngineParameters ep)
    {
        super(ep);

        ///////////////////////// Configuration /////////////////////////

        // Hardware Configuration
        if (ep.getDFEModel().getDFEArchitecture() == DFEArchitecture.MAX4_Maia) {
            BuildConfig Config = new BuildConfig(BuildConfig.Level.FULL_BUILD);
            Config.setBuildEffort(BuildConfig.Effort.HIGH);
            Config.setOptimizationGoal(BuildConfig.OptimizationTechnique.AREA);
            Config.setMPPRCostTableSearchRange(1, 20);
            Config.setMPPRParallelism(8);
            Config.setEnableTimingAnalysis(true);
            setBuildConfig(Config);
            config.setDefaultStreamClockFrequency(Def.KernelFrequencyMAX4);
            config.setAllowNonMultipleTransitions(true);
		}	
		
		// Simulation Configuration
        getCurrentKernelConfig().simulation.setRAMAddressCollisionBehaviour(KernelConfiguration.SimulationOptions.SimulationBehaviour.IGNORE);


        ///////////////////////// Kernel Configuration /////////////////////////

        KernelBlock k = addKernel(new TRPOKernel(makeKernelParameters(Name)));
        k.getInput("Observation") <== addStreamFromCPU("Observation");
        k.getInput("BiasStd")     <== addStreamFromCPU("BiasStd");
        addStreamToCPU("Output") <== k.getOutput("Output");
    }


    private static EngineInterface RunTRPO() {

        EngineInterface ei = new EngineInterface("RunTRPO");

        // Number of ticks to run        
        InterfaceParam NumTicks = ei.addParam("Ticks", CPUTypes.INT);
        ei.setTicks(Name, NumTicks);
 
        
        ///////////////////////// Observation /////////////////////////
        
        // Parameters
        int NumLayers     = Def.NumLayers;
        int  [] LayerSize = Def.LayerSize;
        int  [] NumBlocks = Def.NumBlocks;

        // Length of Weight and VWeight Initialisation Vector
        int WeightInitVecLength = 0;
        for (int i=0; i<NumLayers-1; ++i) {
            WeightInitVecLength += 2*LayerSize[i]*LayerSize[i+1] / NumBlocks[i];
        }
        
        // Length of Observation Vector - Note that it's padded
        int ObservVecLength = WeightInitVecLength + Def.NumSamples * Def.LayerSize[0] / NumBlocks[0];
        int ObservVecSize   = CPUTypes.DOUBLE.sizeInBytes() * NumBlocks[0] * ObservVecLength;
        ei.setStream("Observation", CPUTypes.DOUBLE, ObservVecSize);


        ///////////////////////// BiasStd /////////////////////////
        
        // Length of Bias, VBias and Std Stream
        int BiasStdVecLength = 0;
        for (int i=1; i<NumLayers; ++i) {
            BiasStdVecLength += 2*LayerSize[i];
        }
        
        int BiasStdSize = CPUTypes.DOUBLE.sizeInBytes() * BiasStdVecLength;
        ei.setStream("BiasStd", CPUTypes.DOUBLE, BiasStdSize);        


        ///////////////////////// Output /////////////////////////
        
        ei.setStream("Output", CPUTypes.DOUBLE, CPUTypes.DOUBLE.sizeInBytes()*NumTicks);
        
        return ei;
    }

    // Main Function
    public static void main(String[] args) {
    
        TRPOManager manager = new TRPOManager(new EngineParameters(args));
        manager.createSLiCinterface(RunTRPO());
        manager.build();
    }
    
}
