import com.maxeler.maxcompiler.v2.kernelcompiler.KernelConfiguration;
import com.maxeler.maxcompiler.v2.managers.custom.CustomManager;
import com.maxeler.maxcompiler.v2.managers.custom.blocks.KernelBlock;
import com.maxeler.maxcompiler.v2.managers.BuildConfig;
import com.maxeler.maxcompiler.v2.managers.DFEArchitecture;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.CPUTypes;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.EngineInterface.Direction;
import com.maxeler.maxcompiler.v2.managers.engine_interfaces.InterfaceParam;
import com.maxeler.maxcompiler.v2.build.EngineParameters;

import java.lang.Math;

public class TRPOManager extends CustomManager{

    private static final String Name  = "TRPOKernel";


    TRPOManager(EngineParameters ep)
    {
        super(ep);

        ///////////////////////// Configuration /////////////////////////

        // Hardware Configuration
        if (ep.getDFEModel().getDFEArchitecture() == DFEArchitecture.MAX4_Maia) {
            BuildConfig Config = new BuildConfig(BuildConfig.Level.FULL_BUILD);
            Config.setBuildEffort(BuildConfig.Effort.VERY_HIGH);
            Config.setOptimizationGoal(BuildConfig.OptimizationTechnique.AREA);
            Config.setMPPRCostTableSearchRange(1, 10);
            Config.setMPPRParallelism(6);
            Config.setEnableTimingAnalysis(true);
            setBuildConfig(Config);
            config.setDefaultStreamClockFrequency(Def.KernelFrequencyMAX4);
            config.setAllowNonMultipleTransitions(true);
        }	
		
		// Simulation Configuration
        getCurrentKernelConfig().simulation.setRAMAddressCollisionBehaviour(KernelConfiguration.SimulationOptions.SimulationBehaviour.IGNORE);


        ///////////////////////// Kernel Configuration /////////////////////////

        KernelBlock k = addKernel(new TRPOKernel(makeKernelParameters(Name)));
        k.getInput("Observation") <== addStreamFromCPU("Observation");
        k.getInput("BiasStd")     <== addStreamFromCPU("BiasStd");
        addStreamToCPU("FVP")     <== k.getOutput("FVP");
    }


    private static EngineInterface RunTRPO() {

        EngineInterface ei = new EngineInterface("RunTRPO");

        // Parameters
        int NumLayers     = Def.NumLayers;
        int  [] LayerSize = Def.LayerSize;
        int  [] NumBlocks = Def.NumBlocks;
        int  [] BlockDim  = new int[Def.NumLayers];
        for (int i=0; i<NumLayers; ++i) BlockDim[i] = LayerSize[i] / NumBlocks[i];


        ///////////////////////// Inputs /////////////////////////

        // NumSamples
        InterfaceParam NumSamples = ei.addParam("NumSamples", CPUTypes.UINT32);
        ei.setScalar(Name, "NumSamples", NumSamples);
        
        // Length of Weight and VWeight Initialisation Vector
        int WeightInitVecLength = 0;
        for (int i=0; i<NumLayers-1; ++i) {
            WeightInitVecLength += 2 * BlockDim[i] * LayerSize[i+1];
        }
        
        // Length of Observation Vector - Note that it's padded
        InterfaceParam ObservVecLength = WeightInitVecLength + NumSamples * BlockDim[0];
        InterfaceParam ObservVecSize   = CPUTypes.DOUBLE.sizeInBytes() * NumBlocks[0] * ObservVecLength;
        ei.setStream("Observation", CPUTypes.DOUBLE, ObservVecSize);
        
        // Length of Bias, VBias and Std Stream
        int BiasStdVecLength = LayerSize[NumLayers-1];
        for (int i=1; i<NumLayers; ++i) {
            BiasStdVecLength += 2*LayerSize[i];
        }
        
        int BiasStdSize = CPUTypes.DOUBLE.sizeInBytes() * BiasStdVecLength;
        ei.setStream("BiasStd", CPUTypes.DOUBLE, BiasStdSize);        


        ///////////////////////// Output /////////////////////////
        
        // Length of FVP Result
        int FVPLength = 0;
        for (int i=0; i<NumLayers-1; ++i) {
            FVPLength += LayerSize[i] * LayerSize[i+1];
            FVPLength += LayerSize[i+1];
        }
        ei.setStream("FVP", CPUTypes.DOUBLE, CPUTypes.DOUBLE.sizeInBytes()*FVPLength);


        ///////////////////////// Ticks /////////////////////////

        // Number of Ticks
        int MaxBlkDim0Dim2 = Math.max(BlockDim[0], BlockDim[2]);
        int FwdPropCyclesPerSample = BlockDim[0] + (BlockDim[1]-1)*MaxBlkDim0Dim2 + BlockDim[2]*BlockDim[3];
        int BwdPropCyclesPerSample = BlockDim[1]*MaxBlkDim0Dim2 + BlockDim[2]*BlockDim[3];
        int PropCyclesPerSample    = Math.max(FwdPropCyclesPerSample, BwdPropCyclesPerSample);
        InterfaceParam NumTicks = WeightInitVecLength + PropCyclesPerSample*(NumSamples+1) + FVPLength + 20;
        ei.setTicks(Name, NumTicks);

        return ei;
    }

    // Main Function
    public static void main(String[] args) {
    
        TRPOManager manager = new TRPOManager(new EngineParameters(args));
        manager.createSLiCinterface(RunTRPO());
        manager.build();
    }
    
}
