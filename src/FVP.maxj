import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import java.lang.Math;

/**
 * Propagation: Several layers connected together to formulate a neural network
 *
 * @author Patrick Shao
 *
 * @param <NumLayers> Number of layers in the network: [Input] --> [Hidden 1] --> [Hidden 2] --> [Output] is 4 layers.
 * @param <LayerSize> Size of each layer in the network
 * @param <NumBlocks> Parallelism Factor in each layer, the vector of that layer's width will be NumBlocks
 * @param <AcFunc> Activation Function of each layer, note that AcFunc[0] is not used as Observation is given
 * @param <NumSamples> Number of samples to process (size of the data set)
 * @param <Observation> Input to the first layer (observation data)
 *                      Note: During Initialisation, Observation is used to stream W and VW for each layer
 * @param <BiasStdInitData> Initialisation Data for Bias, VBias, Std, and VStd
 *                      Note: BiasStdInitData is Bias and VBias for each layer, to be followed by Std and VStd
 * @param <beginInit> begin initialisation. Weight initialisation and bias initialisation are independent.
 * @param <beginFVPCalc> begin Fisher Vector Product Calculation for the data set
 *
 */


class FVP extends KernelLib{

    private DFEVar EnObservationInput;
    private DFEVar EnBiasStdInput;
    private DFEVector<DFEVar> Mean;
    private DFEVector<DFEVar> Ry;
    
    public DFEVar getEnObservationInput()       {return EnObservationInput;}
    public DFEVar getEnBiasStdInput()           {return EnBiasStdInput;}
    public DFEVector<DFEVar> getMean()          {return Mean;}
    public DFEVector<DFEVar> getRy()            {return Ry;}
    
    FVP(  KernelLib owner,
          int NumLayers,
          int [] LayerSize,
          int [] NumBlocks,
          char [] AcFunc,
          int NumSamples,
          int BufferDepth,
          DFEVector<DFEVar> Observation,
          DFEVar BiasStdInitData,
          DFEVar beginInit,
          DFEVar beginFVPCalc
          )
    {

    super(owner);
    
    /////////////////////// Parameters ///////////////////////
    
    // Argument Check - currently we assume 4 layers:
    // e.g. [Input] --> [Hidden 1] --> [Hidden 2] --> [Output] is 4 layers.    
    if (NumLayers!=4) {
        throw new IllegalArgumentException("[ERROR] Currently we assume 4 layers.");
    }
    if ((LayerSize.length!=NumLayers)||(AcFunc.length!=NumLayers)||(NumBlocks.length!=NumLayers)) {
        throw new IllegalArgumentException("[ERROR] Length of LayerSize, AcFunc and numBlocks must be NumLayers.");
    }
    
    // Example LayerSize
    //  Humanoid: 376 - 128 - 64 - 17
    //       Ant: 111 -  64 - 32 -  8
    // Example NumBlocks
    // NumBlocks: 32 - 8 - 4 - 4
    
    // Calculate BlockDim
    int [] BlockDim = new int[NumLayers];
    for (int i=0; i<NumLayers; ++i) BlockDim[i] = LayerSize[i] / NumBlocks[i];

    // Number of Cycles needed to do forward and backward propagation for one sample
    // TODO Need to consider OutBlockDimCycleTime
    int NumCyclesPerSample = BlockDim[0] * BlockDim[1] + 200;
    
    // TODO Pipelining between successive inputs
    // Total Number of Cycles
    int TotalNumCycles = NumCyclesPerSample * NumSamples;

    

    /////////////////////// High Level Control ///////////////////////
    
    // TODO Pipelining between successive inputs
    
    // Tick
    DFEVar Tick = control.count.simpleCounter(32);

    
    /////////////////////// Control - Weight Initialisation ///////////////////////
    
    // Parameters
    int FstLayerWeightInitCycles = 2 * BlockDim[0] * LayerSize[1];
    int SndLayerWeightInitCycles = 2 * BlockDim[1] * LayerSize[2];
    int TrdLayerWeightInitCycles = 2 * BlockDim[2] * LayerSize[3];
    int WeightInitCycles = FstLayerWeightInitCycles + SndLayerWeightInitCycles + TrdLayerWeightInitCycles;
    
    // Weight Initialisation Counter
    DFEVar beginWeightInit = beginInit;
    AddrGenerator WeightInitCounter = new AddrGenerator(this, 1, WeightInitCycles, beginWeightInit);
    DFEVar    WeightInitCount = WeightInitCounter.getAddr();
    DFEVar isWeightInitiating = WeightInitCounter.isValid();
    
    // Control Signals for Each Layer
    DFEVar beginWeightInitFstLayer = isWeightInitiating & (WeightInitCount === 0);
    DFEVar beginWeightInitSndLayer = isWeightInitiating & (WeightInitCount === FstLayerWeightInitCycles);
    DFEVar beginWeightInitTrdLayer = isWeightInitiating & (WeightInitCount === FstLayerWeightInitCycles + SndLayerWeightInitCycles);

    // Weight Initialisation Signal - Selection Signal to be used in MUX
    DFEVar isFstLayerWeightInitiating = isWeightInitiating & (WeightInitCount  < FstLayerWeightInitCycles);
    DFEVar isSndLayerWeightInitiating = isWeightInitiating & (WeightInitCount >= FstLayerWeightInitCycles) & 
                                        (WeightInitCount < FstLayerWeightInitCycles + SndLayerWeightInitCycles);
    DFEVar isTrdLayerWeightInitiating = isWeightInitiating & (WeightInitCount >= FstLayerWeightInitCycles + SndLayerWeightInitCycles);


    /////////////////////// Control - Bias Initialisation ///////////////////////

    // TODO Initialise Std after initialising Bias and VBias

    // Parameters
    int FstLayerBiasInitCycles = 2 * LayerSize[1];
    int SndLayerBiasInitCycles = 2 * LayerSize[2];
    int TrdLayerBiasInitCycles = 2 * LayerSize[3];
    int BiasInitCycles = FstLayerBiasInitCycles + SndLayerBiasInitCycles + TrdLayerBiasInitCycles;
    
    // Bias Initialisation Counter
    DFEVar beginBiasInit = beginInit;
    AddrGenerator BiasInitCounter = new AddrGenerator(this, 1, BiasInitCycles, beginBiasInit);
    DFEVar    BiasInitCount = BiasInitCounter.getAddr();
    DFEVar isBiasInitiating = BiasInitCounter.isValid();
    
    // Control Signals for Each Layer
    DFEVar beginBiasInitFstLayer = isBiasInitiating & (BiasInitCount === 0);
    DFEVar beginBiasInitSndLayer = isBiasInitiating & (BiasInitCount === FstLayerBiasInitCycles);
    DFEVar beginBiasInitTrdLayer = isBiasInitiating & (BiasInitCount === FstLayerBiasInitCycles + SndLayerBiasInitCycles);


    /////////////////////// Control - Forward Propagation ///////////////////////
    
    // Total Counter
    AddrGenerator TotalCounter = new AddrGenerator(this, 1, TotalNumCycles, beginFVPCalc);
    DFEVar isFVPCalculating = TotalCounter.isValid();
    
    // Inner Loop - Counting the current sample
    // Note: When this counter wraps, it means the data for the current sample is no longer needed.
    //       So that its values in the buffer can be overwritten by subsequent items.
    Count.Params InnerLoopCounterParam = control.count.makeParams(MathUtils.bitsToAddress(NumCyclesPerSample))
                                                  .withInitValue(0)
                                                  .withMax(NumCyclesPerSample)
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(beginFVPCalc);
    Counter InnerLoopCounter = control.count.makeCounter(InnerLoopCounterParam);
    DFEVar InnerLoopCount = InnerLoopCounter.getCount();

    // Outer Loop - Currently processing #OuterLoopCount sample
    Count.Params OuterLoopCounterParam = control.count.makeParams(MathUtils.bitsToRepresentUnsigned(NumSamples))
                                                  .withInitValue(1)
                                                  .withMax(NumSamples)
                                                  .withEnable(InnerLoopCounter.getWrap())
                                                  .withWrapMode(WrapMode.STOP_AT_MAX)
                                                  .withReset(beginFVPCalc);
    Counter OuterLoopCounter = control.count.makeCounter(OuterLoopCounterParam);
    DFEVar OuterLoopCount = OuterLoopCounter.getCount();
    
    // Counter for Controlled Input
    DFEVar beginNewSample = (InnerLoopCount === 0) & isFVPCalculating;
    AddrGenerator NewSampleInputCounter = new AddrGenerator(this, 1, BlockDim[0], beginNewSample);
    DFEVar isStreamingNewSample = NewSampleInputCounter.isValid();


    /////////////////////// Overall Input Control ///////////////////////

    // Input Control Signal for Observation
    EnObservationInput = isWeightInitiating | isStreamingNewSample;

    // Input Control Signal for BiasStdInitData
    EnBiasStdInput = isBiasInitiating;


    /////////////////////// Input Buffer ///////////////////////

    // Input Buffer Write Control
    // TODO Currently we begin the forward propagation of a new item as soon as the first layer finishes
    //      Currently we do not handle the overwriting issue
    DFEVar beginNextSampleNextTick = InnerLoopCounter.getWrap() & isFVPCalculating;
    Count.Params BufferWrAddrRowCounterParam = control.count.makeParams(MathUtils.bitsToAddress(BufferDepth))
                                                  .withInitValue(0)
                                                  .withMax(BufferDepth)
                                                  .withEnable(beginNextSampleNextTick)
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(beginFVPCalc);
    Counter BufferWrAddrRowCounter = control.count.makeCounter(BufferWrAddrRowCounterParam);
    DFEVar BufferWrAddrRow = BufferWrAddrRowCounter.getCount();    

    // Buffering Input
    DFEVar InBufferWrAddrRow = BufferWrAddrRow;
    DFEVar beginInBufferWrite = beginNewSample;
    // TODO Need to modify InputBuffer.maxj and add control logic to support back propagation
    // TODO Currently ReadAddr (for back propagation) is invalid
    DFEVar InBufferReadAddrRow = constant.var(dfeUInt(MathUtils.bitsToAddress(BufferDepth)), 2);
    DFEVar beginInBufferRead = constant.var(dfeUInt(1), 0);
    InputBuffer Buffer0 = new InputBuffer(this, BlockDim[0], NumBlocks[0], BufferDepth, Observation, 
                              InBufferWrAddrRow, beginInBufferWrite, InBufferReadAddrRow, beginInBufferRead);
    DFEVector<DFEVar>  y_0 = Buffer0.getFwdData(); 
    DFEVector<DFEVar> Ry_0 = constant.vect(BlockDim[0], 0);


    /////////////////////// First Layer ///////////////////////

    // First Layer: Layer[0] => Layer[1]
    DFEVar beginFwdPropFst = beginNewSample;
    DFEVector<DFEVar> y_0_in = y_0.getType().newInstance(this);
    for (int i=0; i<NumBlocks[0]; ++i) {
        y_0_in[i] <== isFstLayerWeightInitiating ? Observation[i] : y_0[i];
    }
    Layer FstLayer = new Layer(this, 0, AcFunc[1], BlockDim[0], NumBlocks[0], BlockDim[1], NumBlocks[1], y_0_in, Ry_0,
                                     BiasStdInitData, beginWeightInitFstLayer, beginBiasInitFstLayer, beginFwdPropFst);
    DFEVector<DFEVar>  y_1_toBuffer = FstLayer.getY();
    DFEVector<DFEVar> Ry_1_toBuffer = FstLayer.getRy();
    DFEVar FstLayerOutputValid      = FstLayer.isValid();
    DFEVar FstLayerFirstResultReady = FstLayer.isFirstItemReady();
    
    // Layer Buffer: Buffering y_1 and Ry_1
    DFEVar Buffer1WriteAddrRow     = BufferWrAddrRow;
    DFEVar Buffer1beginWrFwdData   = FstLayerFirstResultReady;
    DFEVar Buffer1isFwdDataInValid = FstLayerOutputValid;
    DFEVar Buffer1ReadAddrRow      = Reductions.streamHold(Buffer1WriteAddrRow, Buffer1beginWrFwdData);
    DFEVar Buffer1ReadAddrCol      = dfeUInt(MathUtils.bitsToAddress(BlockDim[1])).newInstance(this);
    LayerBuffer Buffer1 = new LayerBuffer(this, 1, BlockDim[1], NumBlocks[1], BlockDim[1], NumBlocks[1], BufferDepth, 
                                          y_1_toBuffer, Ry_1_toBuffer, Buffer1WriteAddrRow, Buffer1beginWrFwdData, 
                                          Buffer1isFwdDataInValid, Buffer1ReadAddrRow, Buffer1ReadAddrCol);
    DFEVector<DFEVar>  y_1 = Buffer1.getY();
    DFEVector<DFEVar> Ry_1 = Buffer1.getRy();
    
    
    /////////////////////// Second Layer ///////////////////////
    
    // Input Layer calculates a new vector every BlockDim[0] cycles, which is the InputLatency for MidLayer.
    // TODO BlockDim[0] may be smaller than OutBlockDim of the MidLayer. So before the MidLayer finishes, 
    //      FstLayer may have already moved to the next input, resulting in a RowAddr mismatch
    //      Ideally, there should be min(OutBlockDim, CompLatency) of MidLayer >= InBlockDim of FstLayer
    //      If RowAddr mismatch happens, consider Buffer1ReadAddrRow = Reductions.streamHold(Buffer1WriteAddrRow, Buffer1beginWrFwdData);
    //      However this only works when MidLayer finishes current sample before InLayer outputs the first result of next item
    //
    // TODO Pay special attention to OutBlockDimCycleTime = max(BlockDim[0], BlockDim[2], CompLatency)
    
    // Second Layer: Layer[1] => Layer[2]
    int OutBlockDimCycleTime = Math.max(BlockDim[0], BlockDim[2]);
    DFEVar beginFwdPropSnd = FstLayerFirstResultReady;
    DFEVector<DFEVar> y_1_in = y_1.getType().newInstance(this);
    for (int i=0; i<NumBlocks[1]; ++i) {
        y_1_in[i] <== isSndLayerWeightInitiating ? Observation[i] : y_1[i];
    }
    MidLayer SndLayer = new MidLayer(this, 1, AcFunc[2], BlockDim[1], NumBlocks[1], BlockDim[2], NumBlocks[2],
                                           OutBlockDimCycleTime, y_1_in, Ry_1, BiasStdInitData,
                                           beginWeightInitSndLayer, beginBiasInitSndLayer, beginFwdPropSnd);
    DFEVector<DFEVar>  y_2_toBuffer = SndLayer.getY();
    DFEVector<DFEVar> Ry_2_toBuffer = SndLayer.getRy();
    DFEVar SndLayerOutputValid      = SndLayer.isValid();
    DFEVar SndLayerFirstResultReady = SndLayer.isFirstItemReady();
    Buffer1ReadAddrCol <== SndLayer.getInputReadOffsetAddr();
    
    // Layer Buffer: Buffering y_2 and Ry_2
    DFEVar Buffer2WriteAddrRow     = Buffer1ReadAddrRow;
    DFEVar Buffer2beginWrFwdData   = SndLayerFirstResultReady;
    DFEVar Buffer2isFwdDataInValid = SndLayerOutputValid;
    DFEVar Buffer2ReadAddrRow      = Reductions.streamHold(Buffer2WriteAddrRow, Buffer2beginWrFwdData);
    DFEVar Buffer2ReadAddrCol      = dfeUInt(MathUtils.bitsToAddress(BlockDim[2])).newInstance(this);
    LayerBuffer Buffer2 = new LayerBuffer(this, 2, BlockDim[2], NumBlocks[2], BlockDim[2], NumBlocks[2], BufferDepth, 
                                          y_2_toBuffer, Ry_2_toBuffer, Buffer2WriteAddrRow, Buffer2beginWrFwdData, 
                                          Buffer2isFwdDataInValid, Buffer2ReadAddrRow, Buffer2ReadAddrCol);
    DFEVector<DFEVar>  y_2 = Buffer2.getY();
    DFEVector<DFEVar> Ry_2 = Buffer2.getRy();    
    

    /////////////////////// Third Layer ///////////////////////

    // Third Layer: Layer[2] => Layer[3]
    DFEVar beginFwdPropTrd = SndLayerFirstResultReady;
    DFEVector<DFEVar> y_2_in = y_2.getType().newInstance(this);
    for (int i=0; i<NumBlocks[2]; ++i) {
        y_2_in[i] <== isTrdLayerWeightInitiating ? Observation[i] : y_2[i];
    }
    Layer TrdLayer = new Layer(this, 2, AcFunc[3], BlockDim[2], NumBlocks[2], BlockDim[3], NumBlocks[3], y_2_in, Ry_2, 
                                     BiasStdInitData, beginWeightInitTrdLayer, beginBiasInitTrdLayer, beginFwdPropTrd);
    DFEVector<DFEVar>  y_3_toBuffer = TrdLayer.getY();
    DFEVector<DFEVar> Ry_3_toBuffer = TrdLayer.getRy();
    DFEVar TrdLayerOutputValid      = TrdLayer.isValid();
    DFEVar TrdLayerFirstResultReady = TrdLayer.isFirstItemReady();
    Buffer2ReadAddrCol <== TrdLayer.getInputReadOffsetAddr();

    // Forward Propagation Result        
    Mean =  y_3_toBuffer;
    Ry   = Ry_3_toBuffer;
    

    /////////////////////// Debug ///////////////////////

    debug.simPrintf(beginNewSample, "[%4d] >>>>>>>>>>>> Begin Sample [%d] >>>>>>>>>>>>\n", Tick, OuterLoopCount);

    // Forward Propagation Results
    debug.simPrintf(TrdLayerOutputValid, "[%4d] y[0:3]=(%.12f, %.12f, %.12f, %.12f), Ry[0:3]=(%.12f, %.12f, %.12f, %.12f)\n", Tick, Mean[0], Mean[1], Mean[2], Mean[3], Ry[0], Ry[1], Ry[2], Ry[3]);

    
    
    }
}
