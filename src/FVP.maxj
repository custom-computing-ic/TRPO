import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import java.lang.Math;

/**
 * Propagation: Several layers connected together to formulate a neural network
 *
 * @author Patrick Shao
 *
 * @param <NumLayers> Number of layers in the network: [Input] --> [Hidden 1] --> [Hidden 2] --> [Output] is 4 layers.
 * @param <LayerSize> Size of each layer in the network
 * @param <NumBlocks> Parallelism Factor in each layer, the vector of that layer's width will be NumBlocks
 * @param <AcFunc> Activation Function of each layer, note that AcFunc[0] is not used as Observation is given
 * @param <NumSamples> Number of samples to process (size of the data set)
 * @param <Observation> Input to the first layer (observation data)
 *                      Note: During Initialisation, Observation is used to stream W and VW for each layer
 * @param <BiasStdInitData> Initialisation Data for Bias, VBias and Std
 *                      Note: BiasStdInitData is Bias and VBias for each layer, to be followed by Std
 * @param <beginInit> begin initialisation. Weight initialisation and bias initialisation are independent.
 * @param <beginFVPCalc> begin Fisher Vector Product Calculation for the data set
 *
 */


class FVP extends KernelLib{

    private DFEVar EnObservationInput;
    private DFEVar EnBiasStdInput;
    private DFEVector<DFEVar> Mean;
    private DFEVector<DFEVar> Ry;
    
    public DFEVar getEnObservationInput()       {return EnObservationInput;}
    public DFEVar getEnBiasStdInput()           {return EnBiasStdInput;}
    public DFEVector<DFEVar> getMean()          {return Mean;}
    public DFEVector<DFEVar> getRy()            {return Ry;}
    
    FVP(  KernelLib owner,
          int NumLayers,
          int [] LayerSize,
          int [] NumBlocks,
          char [] AcFunc,
          int NumSamples,
          int BufferDepth,
          DFEVector<DFEVar> Observation,
          DFEVar BiasStdInitData,
          DFEVar beginInit,
          DFEVar beginFVPCalc
          )
    {

    super(owner);
    
    /////////////////////// Parameters ///////////////////////
    
    // Argument Check - currently we assume 4 layers:
    // e.g. [Input] --> [Hidden 1] --> [Hidden 2] --> [Output] is 4 layers.    
    if (NumLayers!=4) {
        throw new IllegalArgumentException("[ERROR] Currently we assume 4 layers.");
    }
    if ((LayerSize.length!=NumLayers)||(AcFunc.length!=NumLayers)||(NumBlocks.length!=NumLayers)) {
        throw new IllegalArgumentException("[ERROR] Length of LayerSize, AcFunc and numBlocks must be NumLayers.");
    }
    
    // Example LayerSize
    //  Humanoid: 376 - 128 - 64 - 17
    //       Ant: 111 -  64 - 32 -  8
    // Example NumBlocks
    // NumBlocks: 32 - 8 - 4 - 4
    
    // Calculate BlockDim
    int [] BlockDim = new int[NumLayers];
    for (int i=0; i<NumLayers; ++i) BlockDim[i] = LayerSize[i] / NumBlocks[i];

    // Number of Cycles needed to do forward and backward propagation for one sample
    // TODO Need to consider OutBlockDimCycleTime
    int NumCyclesPerSample = BlockDim[0] * BlockDim[1] + 200;
    
    // TODO Pipelining between successive inputs
    // Total Number of Cycles
    int TotalNumCycles = NumCyclesPerSample * NumSamples;

    
    /////////////////////// Types ///////////////////////

    // Type of Buffer Read and Write Row Address
    DFEType BufferRowAddrType = dfeUInt(MathUtils.bitsToAddress(BufferDepth));

    // Type of each layer
    DFEVectorType<DFEVar> Y0_Type = new DFEVectorType<DFEVar>(Def.DataType, NumBlocks[0]);
    DFEVectorType<DFEVar> Y1_Type = new DFEVectorType<DFEVar>(Def.DataType, NumBlocks[1]);
    DFEVectorType<DFEVar> Y2_Type = new DFEVectorType<DFEVar>(Def.DataType, NumBlocks[2]);
    DFEVectorType<DFEVar> Y3_Type = new DFEVectorType<DFEVar>(Def.DataType, NumBlocks[3]);


    /////////////////////// High Level Control ///////////////////////
    
    // TODO Pipelining between successive inputs
    
    // Tick
    DFEVar Tick = control.count.simpleCounter(32);

    
    /////////////////////// Control - Weight Initialisation ///////////////////////
    
    // Parameters
    int FstLayerWeightInitCycles = 2 * BlockDim[0] * LayerSize[1];
    int SndLayerWeightInitCycles = 2 * BlockDim[1] * LayerSize[2];
    int TrdLayerWeightInitCycles = 2 * BlockDim[2] * LayerSize[3];
    int WeightInitCycles = FstLayerWeightInitCycles + SndLayerWeightInitCycles + TrdLayerWeightInitCycles;
    
    // Weight Initialisation Counter
    DFEVar beginWeightInit = beginInit;
    AddrGenerator WeightInitCounter = new AddrGenerator(this, 1, WeightInitCycles, beginWeightInit);
    DFEVar    WeightInitCount = WeightInitCounter.getAddr();
    DFEVar isWeightInitiating = WeightInitCounter.isValid();
    
    // Control Signals for Each Layer
    DFEVar beginWeightInitFstLayer = isWeightInitiating & (WeightInitCount === 0);
    DFEVar beginWeightInitSndLayer = isWeightInitiating & (WeightInitCount === FstLayerWeightInitCycles);
    DFEVar beginWeightInitTrdLayer = isWeightInitiating & (WeightInitCount === FstLayerWeightInitCycles + SndLayerWeightInitCycles);

    // Weight Initialisation Signal - Selection Signal to be used in MUX
    DFEVar isFstLayerWeightInitiating = isWeightInitiating & (WeightInitCount  < FstLayerWeightInitCycles);
    DFEVar isSndLayerWeightInitiating = isWeightInitiating & (WeightInitCount >= FstLayerWeightInitCycles) & 
                                        (WeightInitCount < FstLayerWeightInitCycles + SndLayerWeightInitCycles);
    DFEVar isTrdLayerWeightInitiating = isWeightInitiating & (WeightInitCount >= FstLayerWeightInitCycles + SndLayerWeightInitCycles);


    /////////////////////// Control - Bias and Std Initialisation ///////////////////////

    // Parameters
    int FstLayerBiasInitCycles = 2 * LayerSize[1];
    int SndLayerBiasInitCycles = 2 * LayerSize[2];
    int TrdLayerBiasInitCycles = 2 * LayerSize[3];
    int          StdInitCycles = LayerSize[3];
    int BiasStdInitCycles = FstLayerBiasInitCycles + SndLayerBiasInitCycles + TrdLayerBiasInitCycles + StdInitCycles;
    
    // Bias and Std Initialisation Counter
    DFEVar beginBiasStdInit = beginInit;
    AddrGenerator BiasStdInitCounter = new AddrGenerator(this, 1, BiasStdInitCycles, beginBiasStdInit);
    DFEVar    BiasStdInitCount = BiasStdInitCounter.getAddr();
    DFEVar isBiasStdInitiating = BiasStdInitCounter.isValid();
    
    // Control Signals for Each Layer
    DFEVar beginBiasInitFstLayer = isBiasStdInitiating & (BiasStdInitCount === 0);
    DFEVar beginBiasInitSndLayer = isBiasStdInitiating & (BiasStdInitCount === FstLayerBiasInitCycles);
    DFEVar beginBiasInitTrdLayer = isBiasStdInitiating & (BiasStdInitCount === FstLayerBiasInitCycles + SndLayerBiasInitCycles);
    DFEVar beginStdInit = isBiasStdInitiating & (BiasStdInitCount === FstLayerBiasInitCycles + SndLayerBiasInitCycles + TrdLayerBiasInitCycles);


    /////////////////////// Control - Forward Propagation ///////////////////////
    
    // Total Counter
    AddrGenerator TotalCounter = new AddrGenerator(this, 1, TotalNumCycles, beginFVPCalc);
    DFEVar isFVPCalculating = TotalCounter.isValid();
    
    // Inner Loop - Counting the current sample
    // Note: When this counter wraps, it means the data for the current sample is no longer needed.
    //       So that its values in the buffer can be overwritten by subsequent items.
    Count.Params InnerLoopCounterParam = control.count.makeParams(MathUtils.bitsToAddress(NumCyclesPerSample))
                                                  .withInitValue(0)
                                                  .withMax(NumCyclesPerSample)
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(beginFVPCalc);
    Counter InnerLoopCounter = control.count.makeCounter(InnerLoopCounterParam);
    DFEVar InnerLoopCount = InnerLoopCounter.getCount();

    // Outer Loop - Currently processing #OuterLoopCount sample
    Count.Params OuterLoopCounterParam = control.count.makeParams(MathUtils.bitsToRepresentUnsigned(NumSamples))
                                                  .withInitValue(1)
                                                  .withMax(NumSamples)
                                                  .withEnable(InnerLoopCounter.getWrap())
                                                  .withWrapMode(WrapMode.STOP_AT_MAX)
                                                  .withReset(beginFVPCalc);
    Counter OuterLoopCounter = control.count.makeCounter(OuterLoopCounterParam);
    DFEVar OuterLoopCount = OuterLoopCounter.getCount();
    
    // Counter for Controlled Input
    DFEVar beginNewSample = (InnerLoopCount === 0) & isFVPCalculating;
    AddrGenerator NewSampleInputCounter = new AddrGenerator(this, 1, BlockDim[0], beginNewSample);
    DFEVar isStreamingNewSample = NewSampleInputCounter.isValid();


    /////////////////////// Overall Input Control ///////////////////////

    // Input Control Signal for Observation
    EnObservationInput = isWeightInitiating | isStreamingNewSample;

    // Input Control Signal for BiasStdInitData
    EnBiasStdInput = isBiasStdInitiating;


    /////////////////////// Input Buffer ///////////////////////

    // Input Buffer Write Control
    // TODO Currently we begin the forward propagation of a new item as soon as the first layer finishes
    //      Currently we do not handle the overwriting issue
    DFEVar beginNextSampleNextTick = InnerLoopCounter.getWrap() & isFVPCalculating;
    Count.Params BufferWrAddrRowCounterParam = control.count.makeParams(MathUtils.bitsToAddress(BufferDepth))
                                                  .withInitValue(0)
                                                  .withMax(BufferDepth)
                                                  .withEnable(beginNextSampleNextTick)
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(beginFVPCalc);
    Counter BufferWrAddrRowCounter = control.count.makeCounter(BufferWrAddrRowCounterParam);
    DFEVar BufferWrAddrRow = BufferWrAddrRowCounter.getCount();    

    // Buffering Observation (y_0) for Forward Propagation and Backward Propagation.
    // In this buffer R/W Port is used for Forward Propagation (Read Address is automatically generated inside)
    // R Port is used for Back Propagation (Need to supply Read Address externally.)
    DFEVar Buffer0WriteAddrRow         = BufferWrAddrRow;
    DFEVar Buffer0beginWrFwdData       = beginNewSample;
    DFEVar Buffer0BwdReadAddrRow       = Buffer0WriteAddrRow;
    DFEVar Buffer0BwdOffsetReadAddrCol = dfeUInt(MathUtils.bitsToAddress(BlockDim[0])).newInstance(this);

    InputBuffer Buffer0 = new InputBuffer(this, BlockDim[0], NumBlocks[0], BufferDepth, Observation, 
                              Buffer0WriteAddrRow, Buffer0beginWrFwdData, Buffer0BwdReadAddrRow, Buffer0BwdOffsetReadAddrCol);
    DFEVector<DFEVar>  y_0 = Buffer0.getFwdData(); 
    DFEVector<DFEVar> Ry_0 = constant.vect(NumBlocks[0], 0);


    /////////////////////// First Layer ///////////////////////

    // First Layer: Layer[0] => Layer[1]
    DFEVar beginFwdPropFst = beginNewSample;
    DFEVector<DFEVar> y_0_in = y_0.getType().newInstance(this);
    for (int i=0; i<NumBlocks[0]; ++i) {
        y_0_in[i] <== isFstLayerWeightInitiating ? Observation[i] : y_0[i];
    }

    //Inputs for Back Propagation
    int Bwd_RG_1_CycleTime = Math.max(BlockDim[0], BlockDim[2]);
    DFEVector<DFEVar> Bwd_y_0_Fst = Buffer0.getBwdData();
    DFEVector<DFEVar> Bwd_y_1     = Y1_Type.newInstance(this);
    DFEVector<DFEVar> Bwd_RG_1    = Y1_Type.newInstance(this);
    DFEVar beginBwdPropFst = dfeUInt(1).newInstance(this);    

    Layer FstLayer = new Layer(this, 0, AcFunc[1], BlockDim[0], NumBlocks[0], BlockDim[1], NumBlocks[1], Bwd_RG_1_CycleTime,
                                     y_0_in, Bwd_y_0_Fst, Ry_0, Bwd_y_1, Bwd_RG_1, BiasStdInitData,
                                     beginWeightInitFstLayer, beginBiasInitFstLayer, beginFwdPropFst, beginBwdPropFst);
    
    // Outputs for Forward Propagation
    DFEVector<DFEVar>  y_1_toBuffer = FstLayer.getY();
    DFEVector<DFEVar> Ry_1_toBuffer = FstLayer.getRy();
    DFEVar FstLayerOutputValid      = FstLayer.isFwdValid();
    DFEVar FstLayerFirstResultReady = FstLayer.isFwdFirstItemReady();
    
    // Outputs for Back Propagation
    Buffer0BwdOffsetReadAddrCol <== FstLayer.getBwdPrevLayerReadOffsetAddr();
    
    // Layer Buffer: Buffering y_1 and Ry_1
    DFEVar FwdBuf1WriteAddrRow         = BufferWrAddrRow;
    DFEVar FwdBuf1beginWrFwdData       = FstLayerFirstResultReady;
    DFEVar FwdBuf1isFwdDataInValid     = FstLayerOutputValid;
    DFEVar FwdBuf1FwdReadAddrRow       = Reductions.streamHold(FwdBuf1WriteAddrRow, FwdBuf1beginWrFwdData);
    DFEVar FwdBuf1FwdOffsetReadAddrCol = dfeUInt(MathUtils.bitsToAddress(BlockDim[1])).newInstance(this);
    DFEVar FwdBuf1BwdReadAddrRow       = FwdBuf1FwdReadAddrRow;
    DFEVar FwdBuf1BwdOffsetReadAddrCol = dfeUInt(MathUtils.bitsToAddress(BlockDim[1])).newInstance(this);
    
    LayerBuffer FwdBuf1 = new LayerBuffer(this, 1, BlockDim[1], NumBlocks[1], BlockDim[1], NumBlocks[1], BufferDepth, 
                                          y_1_toBuffer, Ry_1_toBuffer, FwdBuf1WriteAddrRow, FwdBuf1beginWrFwdData, 
                                          FwdBuf1isFwdDataInValid, FwdBuf1FwdReadAddrRow, FwdBuf1FwdOffsetReadAddrCol,
                                          FwdBuf1BwdReadAddrRow, FwdBuf1BwdOffsetReadAddrCol);
    DFEVector<DFEVar>  y_1 = FwdBuf1.getFwdY();
    DFEVector<DFEVar> Ry_1 = FwdBuf1.getRy();
    
    
    /////////////////////// Second Layer ///////////////////////
    
    // Input Layer calculates a new vector every BlockDim[0] cycles, which is the InputLatency for MidLayer.
    // TODO BlockDim[0] may be smaller than OutBlockDim of the MidLayer. So before the MidLayer finishes, 
    //      FstLayer may have already moved to the next input, resulting in a RowAddr mismatch
    //      Ideally, there should be min(OutBlockDim, CompLatency) of MidLayer >= InBlockDim of FstLayer
    //      If RowAddr mismatch happens, consider FwdBuf1FwdReadAddrRow = Reductions.streamHold(FwdBuf1WriteAddrRow, FwdBuf1beginWrFwdData);
    //      However this only works when MidLayer finishes current sample before InLayer outputs the first result of next item
    //
    // TODO Pay special attention to OutBlockDimCycleTime = max(BlockDim[0], BlockDim[2], CompLatency)
    
    // Second Layer: Layer[1] => Layer[2]
    int OutBlockDimCycleTime = Math.max(BlockDim[0], BlockDim[2]);
    DFEVar beginFwdPropSnd = FstLayerFirstResultReady;
    DFEVector<DFEVar> y_1_in = y_1.getType().newInstance(this);
    for (int i=0; i<NumBlocks[1]; ++i) {
        y_1_in[i] <== isSndLayerWeightInitiating ? Observation[i] : y_1[i];
    }
    
    // Inputs for Back Propagation
    DFEVector<DFEVar> Bwd_y_1_Snd = FwdBuf1.getBwdY();
    DFEVector<DFEVar> Bwd_y_2     = Y2_Type.newInstance(this);
    DFEVector<DFEVar> Bwd_RG_2    = Y2_Type.newInstance(this);
    DFEVar beginBwdPropSnd        = dfeUInt(1).newInstance(this);

    MidLayer SndLayer = new MidLayer(this, 1, AcFunc[2], BlockDim[1], NumBlocks[1], BlockDim[2], NumBlocks[2], OutBlockDimCycleTime,
                                           y_1_in, Bwd_y_1_Snd, Ry_1, Bwd_y_2, Bwd_RG_2, BiasStdInitData,
                                           beginWeightInitSndLayer, beginBiasInitSndLayer, beginFwdPropSnd, beginBwdPropSnd);

    // Outputs for Forward Propagation
    DFEVector<DFEVar>  y_2_toBuffer = SndLayer.getY();
    DFEVector<DFEVar> Ry_2_toBuffer = SndLayer.getRy();
    DFEVar SndLayerOutputValid      = SndLayer.isFwdValid();
    DFEVar SndLayerFirstResultReady = SndLayer.isFwdFirstItemReady();
    FwdBuf1FwdOffsetReadAddrCol <== SndLayer.getFwdInputReadOffsetAddr();

    // Outputs for Back Propagation
    DFEVector<DFEVar> Bwd_RG_1_toBuffer = SndLayer.getRG();
    DFEVector<DFEVar> Bwd_y_1_toBuffer  = SndLayer.getBwdYVec();
    FwdBuf1BwdOffsetReadAddrCol <== SndLayer.getBwdPrevLayerReadOffsetAddr();
    beginBwdPropFst <== SndLayer.isBwdFirstItemReady();

    // Forward Propagation Layer Buffer: Buffering y_2 and Ry_2
    DFEVar FwdBuf2WriteAddrRow         = FwdBuf1FwdReadAddrRow;
    DFEVar FwdBuf2beginWrFwdData       = SndLayerFirstResultReady;
    DFEVar FwdBuf2isFwdDataInValid     = SndLayerOutputValid;
    DFEVar FwdBuf2FwdReadAddrRow       = Reductions.streamHold(FwdBuf2WriteAddrRow, FwdBuf2beginWrFwdData);
    DFEVar FwdBuf2FwdOffsetReadAddrCol = dfeUInt(MathUtils.bitsToAddress(BlockDim[2])).newInstance(this);
    DFEVar FwdBuf2BwdReadAddrRow       = FwdBuf2FwdReadAddrRow;
    DFEVar FwdBuf2BwdOffsetReadAddrCol = dfeUInt(MathUtils.bitsToAddress(BlockDim[2])).newInstance(this);
    
    LayerBuffer FwdBuf2 = new LayerBuffer(this, 2, BlockDim[2], NumBlocks[2], BlockDim[2], NumBlocks[2], BufferDepth, 
                                          y_2_toBuffer, Ry_2_toBuffer, FwdBuf2WriteAddrRow, FwdBuf2beginWrFwdData, 
                                          FwdBuf2isFwdDataInValid, FwdBuf2FwdReadAddrRow, FwdBuf2FwdOffsetReadAddrCol,
                                          FwdBuf2BwdReadAddrRow, FwdBuf2BwdOffsetReadAddrCol);
    DFEVector<DFEVar>  y_2 = FwdBuf2.getFwdY();
    DFEVector<DFEVar> Ry_2 = FwdBuf2.getRy();    
    
    // Back Propagation Layer Buffer: Buffering Bwd_y_1 and Bwd_RG_1
    // Here we are using the forward propagation functionality of the buffer to buffer the back propagation data
    // so dummy input is supplied to the back propagation part    
    DFEVar BwdBuf1WriteAddrRow     = FwdBuf1FwdReadAddrRow;
    DFEVar BwdBuf1beginWrBwdData   = SndLayer.isBwdFirstItemReady();
    DFEVar BwdBuf1isBwdDataInValid = SndLayer.isBwdValid();
    DFEVar BwdBuf1BwdReadAddrRow   = FwdBuf1FwdReadAddrRow;
    DFEVar BwdBuf1BwdReadAddrCol   = FstLayer.getBwdNextLayerReadOffsetAddr();

    LayerBuffer BwdBuf1 = new LayerBuffer(this, 2, BlockDim[1], NumBlocks[1], BlockDim[1], NumBlocks[1], BufferDepth, 
                                          Bwd_y_1_toBuffer, Bwd_RG_1_toBuffer, BwdBuf1WriteAddrRow, BwdBuf1beginWrBwdData, 
                                          BwdBuf1isBwdDataInValid, BwdBuf1BwdReadAddrRow, BwdBuf1BwdReadAddrCol,
                                          BwdBuf1BwdReadAddrRow, BwdBuf1BwdReadAddrCol);
    Bwd_y_1  <== BwdBuf1.getFwdY();
    Bwd_RG_1 <== BwdBuf1.getRy();    


    /////////////////////// Third Layer ///////////////////////

    // Third Layer: Layer[2] => Layer[3]
    DFEVar beginFwdPropTrd = SndLayerFirstResultReady;
    DFEVector<DFEVar> y_2_in = y_2.getType().newInstance(this);
    for (int i=0; i<NumBlocks[2]; ++i) {
        y_2_in[i] <== isTrdLayerWeightInitiating ? Observation[i] : y_2[i];
    }
    

    // Inputs for Back Propagation
    int Bwd_RG_3_CycleTime = BlockDim[2];
    DFEVector<DFEVar> Bwd_y_2_Trd = FwdBuf2.getBwdY();
    DFEVector<DFEVar> Bwd_y_3     = Y3_Type.newInstance(this);
    DFEVector<DFEVar> Bwd_RG_3    = Y3_Type.newInstance(this);
    DFEVar beginBwdPropTrd        = dfeUInt(1).newInstance(this);
    
    Layer TrdLayer = new Layer(this, 2, AcFunc[3], BlockDim[2], NumBlocks[2], BlockDim[3], NumBlocks[3], Bwd_RG_3_CycleTime,
                                     y_2_in, Bwd_y_2_Trd, Ry_2, Bwd_y_3, Bwd_RG_3, BiasStdInitData,
                                     beginWeightInitTrdLayer, beginBiasInitTrdLayer, beginFwdPropTrd, beginBwdPropTrd);

    // Outputs for Forward Propagation
    DFEVector<DFEVar>  y_3_toBuffer = TrdLayer.getY();
    DFEVector<DFEVar> Ry_3_toBuffer = TrdLayer.getRy();
    DFEVar TrdLayerOutputValid      = TrdLayer.isFwdValid();
    DFEVar TrdLayerFirstResultReady = TrdLayer.isFwdFirstItemReady();
    FwdBuf2FwdOffsetReadAddrCol <== TrdLayer.getFwdInputReadOffsetAddr();

    // Outputs for Back Propagation
    DFEVector<DFEVar> Bwd_RG_2_toBuffer = TrdLayer.getRG();
    DFEVector<DFEVar> Bwd_y_2_toBuffer  = TrdLayer.getBwdYVec();
    FwdBuf2BwdOffsetReadAddrCol         <== TrdLayer.getBwdPrevLayerReadOffsetAddr();
    beginBwdPropSnd                     <== TrdLayer.isBwdFirstItemReady();
    
    // Back Propagation Layer Buffer: Buffering Bwd_y_2 and Bwd_RG_2
    // Here we are using the forward propagation functionality of the buffer to buffer the back propagation data
    // so dummy input is supplied to the back propagation part    
    DFEVar BwdBuf2WriteAddrRow     = FwdBuf1FwdReadAddrRow;
    DFEVar BwdBuf2beginWrBwdData   = TrdLayer.isBwdFirstItemReady();
    DFEVar BwdBuf2isBwdDataInValid = TrdLayer.isBwdValid();
    DFEVar BwdBuf2BwdReadAddrRow   = FwdBuf1FwdReadAddrRow;
    DFEVar BwdBuf2BwdReadAddrCol   = SndLayer.getBwdNextLayerReadOffsetAddr();

    LayerBuffer BwdBuf2 = new LayerBuffer(this, 2, BlockDim[2], NumBlocks[2], BlockDim[2], NumBlocks[2], BufferDepth, 
                                          Bwd_y_2_toBuffer, Bwd_RG_2_toBuffer, BwdBuf2WriteAddrRow, BwdBuf2beginWrBwdData, 
                                          BwdBuf2isBwdDataInValid, BwdBuf2BwdReadAddrRow, BwdBuf2BwdReadAddrCol,
                                          BwdBuf2BwdReadAddrRow, BwdBuf2BwdReadAddrCol);
    Bwd_y_2  <== BwdBuf2.getFwdY();
    Bwd_RG_2 <== BwdBuf2.getRy();


    /////////////////////// Back Propagation Preparation ///////////////////////

    // Std Block
    DFEVar beginStdRead   = beginFwdPropTrd;
    DFEVar isStdReadValid = TrdLayerOutputValid;
    StdBuffer StdBuff = new StdBuffer(this, BlockDim[3], NumBlocks[3], BiasStdInitData, beginStdInit, beginStdRead, isStdReadValid);
    DFEVector<DFEVar> StdSqInv = StdBuff.getStd();
    
    // Calculate RG_3
    DFEVector<DFEVar> RG_3_toBuffer = StdSqInv * Ry_3_toBuffer;

    // Layer Buffer: Buffering y_3 and RG_3
    // Supply dummy input for Buffer3 BwdRead because there is no upper layers
    DFEVar Buffer3WriteAddrRow         = FwdBuf1FwdReadAddrRow;
    DFEVar Buffer3beginWrFwdData       = TrdLayerFirstResultReady;
    DFEVar Buffer3isFwdDataInValid     = TrdLayerOutputValid;
    DFEVar Buffer3FwdReadAddrRow       = Reductions.streamHold(Buffer3WriteAddrRow, Buffer3beginWrFwdData);
    DFEVar Buffer3FwdOffsetReadAddrCol = TrdLayer.getBwdNextLayerReadOffsetAddr();
    
    LayerBuffer Buffer3 = new LayerBuffer(this, 3, BlockDim[3], NumBlocks[3], BlockDim[3], NumBlocks[3], BufferDepth, 
                                          y_3_toBuffer, RG_3_toBuffer, Buffer3WriteAddrRow, Buffer3beginWrFwdData, 
                                          Buffer3isFwdDataInValid, Buffer3FwdReadAddrRow, Buffer3FwdOffsetReadAddrCol,
                                          Buffer3FwdReadAddrRow, Buffer3FwdOffsetReadAddrCol);
    Bwd_y_3  <== Buffer3.getFwdY();
    Bwd_RG_3 <== Buffer3.getRy();


    /////////////////////// Back Propagation ///////////////////////

    // Begin Back Propagation in the Final Layer
    beginBwdPropTrd <== stream.offset(TrdLayerFirstResultReady, -1);



    /////////////////////// Debug ///////////////////////
    
    // Output Forward Propagation Result
    Mean =  y_3_toBuffer;
    Ry   = Ry_3_toBuffer;    


    // Forward Propagation Results
    debug.simPrintf(beginNewSample, "[%4d] >>>>>>>>>>>> Begin Sample [%d] >>>>>>>>>>>>\n", Tick, OuterLoopCount);
    debug.simPrintf(TrdLayer.isFwdValid(), "[%4d] y[0:3]=(%.12f, %.12f, %.12f, %.12f), Ry[0:3]=(%.12f, %.12f, %.12f, %.12f)\n", Tick, Mean[0], Mean[1], Mean[2], Mean[3], Ry[0], Ry[1], Ry[2], Ry[3]);
    
    
    // Back Propagation Results
//    debug.simPrintf(TrdLayer.isFwdFirstItemReady(), "[%4d] First Third Layer Forward Propagation Output is ready.\n", Tick);
//    debug.simPrintf(beginBwdPropTrd, "[%4d] Begin Third Layer Back Propagation...\n", Tick);
//    debug.simPrintf(TrdLayer.isBwdValid(), "[%4d] RG_2[0:3]=(%.12f, %.12f, %.12f, %.12f)\n", Tick, Bwd_RG_2_toBuffer[0], Bwd_RG_2_toBuffer[1], Bwd_RG_2_toBuffer[2], Bwd_RG_2_toBuffer[3]);

//    debug.simPrintf(beginBwdPropSnd, "[%4d] Begin Second Layer Back Propagation...\n", Tick);
//    debug.simPrintf(SndLayer.isBwdValid(), "[%4d] RG_1[0:3]=(%.12f, %.12f, %.12f, %.12f)\n", Tick, Bwd_RG_1_toBuffer[0], Bwd_RG_1_toBuffer[1], Bwd_RG_1_toBuffer[2], Bwd_RG_1_toBuffer[3]);

    
    
    }
}
