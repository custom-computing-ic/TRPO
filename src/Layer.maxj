import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVector;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.composite.DFEVectorType;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.memory.Memory;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Mem.RamWriteMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.Counter;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Count.WrapMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.core.Stream.OffsetExpr;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Reductions;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.Accumulator;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.utils.MathUtils;

import maxpower.KernelBinaryOp.Add;
import maxpower.TreeReduce;

/**
 * A layer of both forward propagation and back propagation
 *
 * @author Patrick Shao
 *
 * @param <ID> The ID of this Layer
 *             Note: Set ID to 0 for input layer, so that FwdPrevRyLayer will be ignored as values are zero. 
 * @param <AcFunc> Activation Function of this Layer
 * @param <InBlockDim> Block Dimension of the Input Vector
 * @param <NumInBlocks> Number of Input Blocks => InputDim = InBlockDim * NumInBlocks
 * @param <OutBlockDim> Block Dimension of the Output Vector
 * @param <NumOutBlocks> Number of Output Blocks => OutputDim = OutBlockDim * NumOutBlocks
 * @param <InBlockDimCycleTime> Number of cycles needed for each inner loop, see description below
 *                               Note: a) A new vector comes every InputLatency cycles.
 *                                     b) In each inner loop there are InBlockDim items to process.
 *                                     c) The computation latency within this block is CompLatency cycles.
 *                                        This can be checked with stream offset value
 *                                     ==> OutBlockDimCycleTime = max(InputLatency, InBlockDim, CompLatency)
 *                                     TotalNumCycles = OutBlockDimCycleTime * OutBlockDim 
 * @param <FwdPrevLayer> y values of previous layer, width should be NumInBlocks.
 *                       Iterating every cycle during computation, using InBlockDim cycles to finish 1 Input Vector
 *                       Note: during initialisation, FwdPrevLayer is used to stream in W and VW.
 * @param <BwdPrevLayer> y values of previous layer, width should be NumInBlocks.
 *                       Iterating every outer iteration.
 * @param <FwdPrevRyLayer> Ry values of previous layer, width should be NumInBlocks
 *                         Iterating every cycle during computation, using InBlockDim cycles to finish 1 Input Vector
 * @param <BwdNextLayer> y values from next layer, width should be NumOutBlocks.
 *                       Iterating every cycle during back propagation.
 * @param <BwdNextRGLayer> Incoming RGLayer values, width should be NumOutBlocks.
 *                         Iterating every cycle during back propagation.
 * @param <BiasInitData> Initialisation Data for Bias and VBias
 * @param <beginWeightInit> begin Weight Initialisation - using FwdPrevLayer to stream in W and VW
 * @param <beginBiasInit> begin Bias Initialisation - using BiasInitData to stream in B and VB
 * @param <beginFwdProp> begin forward propagation
 * @param <beginBwdProp> begin back propagation
 * @param <beginReadBack> begin read back RGW and RGB, which are the fisher vector product
 *
 */

class Layer extends KernelLib{

    private DFEVector<DFEVar> YVec;
    private DFEVector<DFEVar> RyVec;
    private DFEVector<DFEVar> RGVec;
    private DFEVector<DFEVar> BwdYVec;
    private DFEVar FwdInputReadOffsetAddr;
    private DFEVar FwdFirstItemReady;
    private DFEVar FwdValid;
    private DFEVar BwdNextLayerReadOffsetAddr;
    private DFEVar BwdPrevLayerReadOffsetAddr;
    private DFEVar BwdFirstItemReady;
    private DFEVar BwdValid;
    private DFEVar RGReadBackData;
    private DFEVar RGReadBackValid;
		
    public DFEVector<DFEVar> getY()                     {return YVec;}
    public DFEVector<DFEVar> getRy()                    {return RyVec;}
    public DFEVector<DFEVar> getRG()                    {return RGVec;}
    public DFEVector<DFEVar> getBwdYVec()               {return BwdYVec;}
    public DFEVar getFwdInputReadOffsetAddr()           {return FwdInputReadOffsetAddr;}
    public DFEVar isFwdFirstItemReady()                 {return FwdFirstItemReady;}
    public DFEVar isFwdValid()                          {return FwdValid;}
    public DFEVar getBwdNextLayerReadOffsetAddr()       {return BwdNextLayerReadOffsetAddr;}
    public DFEVar getBwdPrevLayerReadOffsetAddr()       {return BwdPrevLayerReadOffsetAddr;}
    public DFEVar isBwdFirstItemReady()                 {return BwdFirstItemReady;}
    public DFEVar isBwdValid()                          {return BwdValid;}
    public DFEVar getRGReadBackData()                   {return RGReadBackData;}
    public DFEVar isRGReadBackValid()                   {return RGReadBackValid;}
    
	
    Layer(  KernelLib owner,
            int ID,
            char AcFunc,
            int InBlockDim,
            int NumInBlocks,
            int OutBlockDim,
            int NumOutBlocks,
            int InBlockDimCycleTime,
            DFEVector<DFEVar> FwdPrevLayer,
            DFEVector<DFEVar> BwdPrevLayer,
            DFEVector<DFEVar> FwdPrevRyLayer,
            DFEVector<DFEVar> BwdNextLayer,
            DFEVector<DFEVar> BwdNextRGLayer,
            DFEVar BiasInitData,
            DFEVar beginWeightInit,
            DFEVar beginBiasInit,
            DFEVar beginFwdProp,
            DFEVar beginBwdProp,
            DFEVar beginReadBack)
    {

    super(owner);
    
    /////////////////////// Data Types ///////////////////////
    
    int BlockSize = InBlockDim*OutBlockDim;
    DFEVectorType<DFEVar>  InVecType = new DFEVectorType<DFEVar>(Def.DataType, NumInBlocks);
    DFEVectorType<DFEVar> OutVecType = new DFEVectorType<DFEVar>(Def.DataType, NumOutBlocks);
    DFEVectorType<DFEVector<DFEVar>> FwdGridVecType = new DFEVectorType<DFEVector<DFEVar>>(InVecType, NumOutBlocks);
    DFEVectorType<DFEVector<DFEVar>> BwdGridVecType = new DFEVectorType<DFEVector<DFEVar>>(OutVecType, NumInBlocks);
    DFEType AddrType = dfeUInt(MathUtils.bitsToAddress(BlockSize));



    /*************************************************************************************
    *                             Control - Initialisation                               *
    *************************************************************************************/



    /////////////////////// Address Generation - Weight Initialisation ///////////////////////

    // Cycle                  0*BlockSize ~                  BlockSize - 1 for Weight X[:]Y[0]
    // Cycle                  1*BlockSize ~                2*BlockSize - 1 for Weight X[:]Y[1]
    // ...
    // Cycle   (NumOutBlocks-1)*BlockSize ~     NumOutBlocks*BlockSize - 1 for Weight X[:]Y[NumOutBlocks-1]
    
    // Cycle       NumOutBlocks*BlockSize ~ (NumOutBlocks+1)*BlockSize - 1 for V Weight X[:]Y[0]
    // Cycle   (NumOutBlocks+1)*BlockSize ~ (NumOutBlocks+2)*BlockSize - 1 for V Weight X[:]Y[1]
    // ...
    // Cycle (2*NumOutBlocks-1)*BlockSize ~ (2*NumOutBlocks)*BlockSize - 1 for V Weight X[:]Y[NumOutBlocks-1]
    

    // Reset Signal for Initialisation
    DFEVar WeightInitReset = beginWeightInit;

    // Top Level Control
    AddrGenerator InitCounter = new AddrGenerator(owner, 1, 2*NumOutBlocks*BlockSize, WeightInitReset);
    DFEVar InitCount = InitCounter.getAddr();
    DFEVar isInit    = InitCounter.isValid();
    DFEVar isInitW   = isInit & (InitCount <  NumOutBlocks*BlockSize);
    DFEVar isInitVW  = isInit & (InitCount >= NumOutBlocks*BlockSize);
    
    // InitWPortAddr - Initialisation using R/W port
    Count.Params InitWPortAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(BlockSize))
                                                  .withInitValue(0)
                                                  .withMax(BlockSize)
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(WeightInitReset);
    Counter InitWPortAddrCounter = control.count.makeCounter(InitWPortAddrCounterParam);
    DFEVar InitWPortAddr = InitWPortAddrCounter.getCount();

    // InitWYCount - to Select the block to write according to Y
    Count.Params InitWYCounterParam = control.count.makeParams(MathUtils.bitsToAddress(NumOutBlocks))
                                                  .withInitValue(0)
                                                  .withMax(NumOutBlocks)
                                                  .withEnable(InitWPortAddrCounter.getWrap())
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(WeightInitReset);
    Counter InitWYCounter = control.count.makeCounter(InitWYCounterParam);
    DFEVar InitWYCount = InitWYCounter.getCount();


    /////////////////////// Address Generation - Bias Initialisation ///////////////////////

    // BiasReset Signal for Initialisation
    DFEVar BiasInitReset = beginBiasInit;

    // Top Level Control
    AddrGenerator BiasInitCounter = new AddrGenerator(owner, 1, 2*NumOutBlocks*OutBlockDim, BiasInitReset);
    DFEVar BiasInitCount = BiasInitCounter.getAddr();
    DFEVar isBiasInit    = BiasInitCounter.isValid();
    DFEVar isInitB       = isBiasInit & (BiasInitCount <  NumOutBlocks*OutBlockDim);
    DFEVar isInitVB      = isBiasInit & (BiasInitCount >= NumOutBlocks*OutBlockDim);
    
    // InitBPortAddr - Initialisation using R/W port
    Count.Params InitBPortAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(OutBlockDim))
                                                  .withInitValue(0)
                                                  .withMax(OutBlockDim)
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(BiasInitReset);
    Counter InitBPortAddrCounter = control.count.makeCounter(InitBPortAddrCounterParam);
    DFEVar InitBPortAddr = InitBPortAddrCounter.getCount();

    // BYCount - to Select the block to write according to Y
    Count.Params InitBYCounterParam = control.count.makeParams(MathUtils.bitsToAddress(NumOutBlocks))
                                                  .withInitValue(0)
                                                  .withMax(NumOutBlocks)
                                                  .withEnable(InitBPortAddrCounter.getWrap())
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(BiasInitReset);
    Counter InitBYCounter = control.count.makeCounter(InitBYCounterParam);
    DFEVar InitBYCount = InitBYCounter.getCount();



    /*************************************************************************************
    *                            Control - Forward Propagation                           *
    *************************************************************************************/



    /////////////////////// Address Generation - Forward Propagation ///////////////////////

    // Counter Reset
    DFEVar FwdReset = beginFwdProp;

    // Top Level Control
    AddrGenerator FwdCounter = new AddrGenerator(owner, 1, BlockSize, FwdReset);
    DFEVar isFwdCalculating = FwdCounter.isValid();

    // Row Address in InBlockDim domain - to be used by Weight
    Count.Params FwdRowAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(InBlockDim))
                                                  .withInitValue(0)
                                                  .withMax(InBlockDim)
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(FwdReset);
    Counter FwdRowAddrCounter = control.count.makeCounter(FwdRowAddrCounterParam);
    DFEVar FwdRowAddr = FwdRowAddrCounter.getCount();

    // Col Address in OutBlockDim domain - to be used by Weight, Bias and Temp Result
    Count.Params FwdColAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(OutBlockDim))
                                                  .withInitValue(0)
                                                  .withMax(OutBlockDim)
                                                  .withEnable(FwdRowAddrCounter.getWrap())
                                                  .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                  .withReset(FwdReset);
    Counter FwdColAddrCounter = control.count.makeCounter(FwdColAddrCounterParam);
    DFEVar FwdColAddr = FwdColAddrCounter.getCount();

    // Read Address - vertical in our case
    DFEVar FwdWReadAddr = FwdRowAddr.cast(AddrType) * OutBlockDim + FwdColAddr.cast(AddrType);

    // Offset Read Address for the Input Vector - for previous LayerBuffer
    FwdInputReadOffsetAddr = FwdRowAddr;
    
    // The first item of the result is ready at the end of the first iteration
    FwdFirstItemReady = isFwdCalculating & FwdRowAddrCounter.getWrap() & (FwdColAddr === 0);
    
    // The result is valid on the last cycle of each inner loop iteration
    FwdValid = isFwdCalculating & FwdRowAddrCounter.getWrap();



    /*************************************************************************************
    *                             Control - Back Propagation                             *
    *************************************************************************************/



    /////////////////////// Address Generation - Back Propagation ///////////////////////

    // Counter Reset
    DFEVar BwdReset = beginBwdProp;

    // Top Level Control
    AddrGenerator BwdCounter = new AddrGenerator(owner, 1, InBlockDimCycleTime*OutBlockDim, BwdReset);
    DFEVar isBwdCalculating = BwdCounter.isValid();
    
    // Begin New Column
    Count.Params NewColCounterParam = control.count.makeParams(16)
                                                   .withInitValue(0)
                                                   .withMax(InBlockDimCycleTime)
                                                   .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                   .withReset(BwdReset);
    Counter NewColCounter = control.count.makeCounter(NewColCounterParam);
    DFEVar beginNewCol = (NewColCounter.getCount() === 0) & isBwdCalculating;

    // Row Address in InBlockDim domain - to be used by Weight and Temp Result
    AddrGenerator BwdRowAddrCounter = new AddrGenerator(owner, 1, InBlockDim, beginNewCol);
    DFEVar BwdRowAddr = BwdRowAddrCounter.getAddr();
    DFEVar BwdRowAddrValid = BwdRowAddrCounter.isValid() & isBwdCalculating;

    // Col Address in OutBlockDim domain - to be used by Weight
    DFEVar BwdIncColAddrNextTick = NewColCounter.getWrap();
    AddrGenerator BwdColAddrCounter = new AddrGenerator(owner, 1, OutBlockDim, BwdReset, BwdIncColAddrNextTick);
    DFEVar BwdColAddr = BwdColAddrCounter.getAddr();
    DFEVar isFirstCol = (BwdColAddr === 0);

    // Weight Read Address
    DFEVar BwdWReadAddr = BwdRowAddr.cast(AddrType) * OutBlockDim + BwdColAddr.cast(AddrType);
    
    // Offset Read Address for the BwdNextLayer Vector - for BwdNextLayer and BwdNextRGLayer
    BwdNextLayerReadOffsetAddr = BwdColAddr;
    
    // Offset Read Address for the BwdPrevLayer Vector
    BwdPrevLayerReadOffsetAddr = BwdRowAddr;

    // The first item of the result is ready at the beginning of the last iteration
    BwdFirstItemReady = (BwdColAddr === OutBlockDim-1) & beginNewCol & isBwdCalculating;

    // Is Fwd Output Valid
    BwdValid = (BwdColAddr === OutBlockDim-1) & BwdRowAddrValid;

    // RGW Update is valid when Back Propagation Row Address is Valid
    DFEVar isRGWUpdating = BwdRowAddrValid;

    // RGB Update is valid on the first cycle in each inner loop
    DFEVar isRGBUpdating = isBwdCalculating & beginNewCol;



    /*************************************************************************************
    *                                Control - Read Back                                 *
    *************************************************************************************/



    /////////////////////// Address Generation - Read Back ///////////////////////

    // Number of Cycles Needed
    int RGWReadBackCycles = BlockSize * NumInBlocks * NumOutBlocks;
    int RGBReadBackCycles = OutBlockDim * NumOutBlocks;
    int ReadBackCycles    = RGWReadBackCycles + RGBReadBackCycles;

    // RGW Read Back Reset
    DFEVar RGReadBackReset = beginReadBack;

    // Top Level Control    
    AddrGenerator ReadBackCounter = new AddrGenerator(owner, 1, ReadBackCycles, RGReadBackReset);
    DFEVar ReadBackCount     = ReadBackCounter.getAddr();
    DFEVar isReadingBack     = ReadBackCounter.isValid();
    DFEVar isReadingBackRGW  = (ReadBackCount < RGWReadBackCycles) & isReadingBack;

    // RG Read Column Offset Address - For RGW and RGB
    Count.Params RGReadColOffsetAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(OutBlockDim))
                                                            .withInitValue(0)
                                                            .withMax(OutBlockDim)
                                                            .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                            .withReset(RGReadBackReset);
    Counter RGReadColOffsetAddrCounter = control.count.makeCounter(RGReadColOffsetAddrCounterParam);
    DFEVar RGReadColOffsetAddr = RGReadColOffsetAddrCounter.getCount();

    // RG Read Column Base Address - For RGW and RGB
    Count.Params RGReadColBaseAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(NumOutBlocks))
                                                            .withInitValue(0)
                                                            .withMax(NumOutBlocks)
                                                            .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                            .withEnable(RGReadColOffsetAddrCounter.getWrap())
                                                            .withReset(RGReadBackReset);
    Counter RGReadColBaseAddrCounter = control.count.makeCounter(RGReadColBaseAddrCounterParam);
    DFEVar RGReadColBaseAddr = RGReadColBaseAddrCounter.getCount();
    
    // RG Read Row Offset Address - For RGW
    Count.Params RGReadRowOffsetAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(InBlockDim))
                                                            .withInitValue(0)
                                                            .withMax(InBlockDim)
                                                            .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                            .withEnable(RGReadColBaseAddrCounter.getWrap())
                                                            .withReset(RGReadBackReset);
    Counter RGReadRowOffsetAddrCounter = control.count.makeCounter(RGReadRowOffsetAddrCounterParam);
    DFEVar RGReadRowOffsetAddr = RGReadRowOffsetAddrCounter.getCount();

    // RG Read Row Base Address - For RGW
    Count.Params RGReadRowBaseAddrCounterParam = control.count.makeParams(MathUtils.bitsToAddress(NumInBlocks))
                                                            .withInitValue(0)
                                                            .withMax(NumInBlocks)
                                                            .withWrapMode(WrapMode.COUNT_LT_MAX_THEN_WRAP)
                                                            .withEnable(RGReadRowOffsetAddrCounter.getWrap())
                                                            .withReset(RGReadBackReset);
    Counter RGReadRowBaseAddrCounter = control.count.makeCounter(RGReadRowBaseAddrCounterParam);
    DFEVar RGReadRowBaseAddr = RGReadRowBaseAddrCounter.getCount();
    
    // RGW Read Back Addr
    DFEVar RGWReadBackAddr = RGReadRowOffsetAddr.cast(AddrType) * OutBlockDim + RGReadColOffsetAddr.cast(AddrType);

    // RGB Read Back Addr
    DFEVar RGBReadBackAddr = RGReadColOffsetAddr;
    
    // Read Back Valid
    RGReadBackValid = isReadingBack;



    /*************************************************************************************
    *                                  Overall Control                                   *
    *************************************************************************************/



    DFEVar WPortAddr = isInit ? InitWPortAddr : BwdWReadAddr;
    DFEVar WReadAddr = FwdWReadAddr;
    DFEVar BPortAddr = InitBPortAddr;
    DFEVar BReadAddr = FwdColAddr;
    
    DFEVar RGWReadAddr = isReadingBack ? RGWReadBackAddr : BwdWReadAddr;
    DFEVar RGBReadAddr = isReadingBack ? RGBReadBackAddr : BwdColAddr;



    /*************************************************************************************
    *                                 Memory Allocation                                  *
    *************************************************************************************/



    /////////////////////// Memory Allocation ///////////////////////
    
    // Weight and VWeight Memory Blocks
    DFEVector<DFEVector<DFEVar>>  FwdWGridVec = FwdGridVecType.newInstance(this);
    DFEVector<DFEVector<DFEVar>>  BwdWGridVec = BwdGridVecType.newInstance(this);
    DFEVector<DFEVector<DFEVar>> FwdVWGridVec = FwdGridVecType.newInstance(this);
    for (int X=0; X<NumInBlocks; ++X) {
        for (int Y=0; Y<NumOutBlocks; ++Y) {
            // W Block
            Memory<DFEVar> WBlock = mem.alloc(Def.DataType, BlockSize);
            BwdWGridVec[X][Y] <== WBlock.port(WPortAddr, FwdPrevLayer[X], isInitW & (Y===InitWYCount), RamWriteMode.WRITE_FIRST);
            FwdWGridVec[Y][X] <== WBlock.read(WReadAddr);
            // VW Block
            Memory<DFEVar> VWBlock = mem.alloc(Def.DataType, BlockSize);
            VWBlock.port(WPortAddr, FwdPrevLayer[X], isInitVW & (Y===InitWYCount), RamWriteMode.WRITE_FIRST);
            FwdVWGridVec[Y][X] <== VWBlock.read(WReadAddr);
        }
    }

    // Bias and VBias Memory Blocks
    DFEVector<DFEVar>  Bias = OutVecType.newInstance(this);
    DFEVector<DFEVar> VBias = OutVecType.newInstance(this);
    for (int Y=0; Y<NumOutBlocks; ++Y) {
        // B Block
        Memory<DFEVar> BBlock = mem.alloc(Def.DataType, OutBlockDim);
        BBlock.port(BPortAddr, BiasInitData, isInitB & (Y===InitBYCount), RamWriteMode.WRITE_FIRST);
        Bias[Y] <== BBlock.read(BReadAddr);
        // VB Block
        Memory<DFEVar> VBBlock = mem.alloc(Def.DataType, OutBlockDim);
        VBBlock.port(BPortAddr, BiasInitData, isInitVB & (Y===InitBYCount), RamWriteMode.WRITE_FIRST);
        VBias[Y] <== VBBlock.read(BReadAddr);
    }

    // RGW Memory Blocks
    DFEVector<DFEVector<DFEVar>> BwdRGWRdGridVec = BwdGridVecType.newInstance(this);
    DFEVector<DFEVector<DFEVar>> BwdRGWWrGridVec = BwdGridVecType.newInstance(this);
    DFEVar BwdRGWWrAddr = dfeUInt(MathUtils.bitsToAddress(BlockSize)).newInstance(this);
    DFEVar BwdRGWWrEn   = dfeUInt(1).newInstance(this);
    for (int X=0; X<NumInBlocks; ++X) {
        for (int Y=0; Y<NumOutBlocks; ++Y) {
            // RGW Block
            Memory<DFEVar> RGWBlock = mem.alloc(Def.DataType, BlockSize);
            RGWBlock.port(BwdRGWWrAddr, BwdRGWWrGridVec[X][Y], BwdRGWWrEn, RamWriteMode.WRITE_FIRST);
            BwdRGWRdGridVec[X][Y] <== RGWBlock.read(RGWReadAddr);
        }
    }
    
    // RGB Memory Blocks
    DFEVector<DFEVar> BwdRGBRead  = OutVecType.newInstance(this);
    DFEVector<DFEVar> BwdRGBWrite = OutVecType.newInstance(this);
    DFEVar BwdRGBWrAddr = dfeUInt(MathUtils.bitsToAddress(OutBlockDim)).newInstance(this);
    DFEVar BwdRGBWrEn   = dfeUInt(1).newInstance(this);
    for (int Y=0; Y<NumOutBlocks; ++Y) {
        // RGB Block
        Memory<DFEVar> RGBBlock = mem.alloc(Def.DataType, OutBlockDim);
        RGBBlock.port(BwdRGBWrAddr, BwdRGBWrite[Y], BwdRGBWrEn, RamWriteMode.WRITE_FIRST);
        BwdRGBRead[Y] <== RGBBlock.read(RGBReadAddr);
    }



    /*************************************************************************************
    *                                    Calculation                                     *
    *************************************************************************************/



    /////////////////////// Calculation - Forward Propagation ///////////////////////

    // Accumulator Parameter
    Accumulator.Params FwdAccParam = Reductions.accumulator.makeAccumulatorConfig(Def.DataType)
                                                     .withEnable(isFwdCalculating)
                                                     .withClear(stream.offset(FwdRowAddr, 1)===0);
    // For Debug
    DFEVector<DFEVar> PrevAcY = OutVecType.newInstance(this);

    // Calculate Y and Ry
    // TODO: Optimise bit width to avoid overflow
    YVec  = OutVecType.newInstance(this);
    RyVec = OutVecType.newInstance(this);
    for (int Y=0; Y<NumOutBlocks; ++Y) {
        DFEVector<DFEVar> mult_y = FwdPrevLayer * FwdWGridVec[Y];
        DFEVector<DFEVar> mult_Ry;
        if (ID==0) mult_Ry = FwdPrevLayer * FwdVWGridVec[Y];
        else mult_Ry = FwdPrevRyLayer * FwdWGridVec[Y] + FwdPrevLayer * FwdVWGridVec[Y];
        DFEVar toAccumulator_y  = TreeReduce.reduce(new Add<DFEVar>(), mult_y.getElementsAsList());
        DFEVar toAccumulator_Ry = TreeReduce.reduce(new Add<DFEVar>(), mult_Ry.getElementsAsList());
        DFEVar sum_y  = Reductions.accumulator.makeAccumulator(toAccumulator_y,  FwdAccParam);
        DFEVar sum_Ry = Reductions.accumulator.makeAccumulator(toAccumulator_Ry, FwdAccParam);
        DFEVar prevActivated_y  = sum_y  +  Bias[Y];
        DFEVar prevActivated_Ry = sum_Ry + VBias[Y];
        // For Debug
        PrevAcY[Y] <== prevActivated_y;
        switch (AcFunc) {
            case 't': {
                DFEVar Activated_y = tanh(prevActivated_y);
                 YVec[Y] <== Activated_y;
                RyVec[Y] <== prevActivated_Ry * (1-Activated_y) * (1+Activated_y);
                break;
            }
            case 'l': {
                 YVec[Y] <== prevActivated_y;
                RyVec[Y] <== prevActivated_Ry;
                break;
            }
            default: {
                throw new IllegalArgumentException("Layer["+ID+"]: Activation Function "+AcFunc+" unsupported.");
			}
        }
    }
    
/*
    // For Simulation
    debug.simPrintf(WeightInitReset, "[%4d] Layer[%d] Begin Init Weights...\n", control.count.simpleCounter(32), ID);
    debug.simPrintf(BiasInitReset, "[%4d] Layer[%d] Begin Init Bias...\n", control.count.simpleCounter(32), ID);

    if (ID==0) {
        // Check PreActivated Value - Assuming NumOutBlocks=8 (AntTest)
        // debug.simPrintf(FwdValidValid, "[%4d] W[%2d][%2d] RdAddr=%2d | Y[0:7][%2d]=(%.12f,%.12f,%.12f,%.12f, %.12f,%.12f,%.12f,%.12f), Valid=%d\n", control.count.simpleCounter(32), FwdRowAddr, FwdColAddr, WReadAddr, FwdColAddr, PrevAcY[0], PrevAcY[1], PrevAcY[2], PrevAcY[3], PrevAcY[4], PrevAcY[5], PrevAcY[6], PrevAcY[7], FwdValidValid);

        // Check Activated Value - Assuming NumOutBlocks=8 (AntTest)
        // debug.simPrintf(FwdValidValid, "[%4d] W[%2d][%2d] RdAddr=%2d | Y[0:7][%2d]=(%.12f,%.12f,%.12f,%.12f, %.12f,%.12f,%.12f,%.12f), Valid=%d\n", control.count.simpleCounter(32), FwdRowAddr, FwdColAddr, WReadAddr, FwdColAddr, YVec[0], YVec[1], YVec[2], YVec[3], YVec[4], YVec[5], YVec[6], YVec[7], FwdValid);

        // Check Computation - Assuming NumOutBlock=4 (SwimmerTest)
        // debug.simPrintf(isFwdCalculating, "[%4d] W[%2d][%2d]=W[%2d] | W[0:3][0]=(%f, %f, %f, %f), prev=(%f, %f, %f, %f) | PreAc_y = %f, y=%f | Valid=%d\n", control.count.simpleCounter(32), FwdRowAddr, FwdColAddr, WReadAddr, FwdWGridVec[0][0], FwdWGridVec[0][1], FwdWGridVec[0][2], FwdWGridVec[0][3], FwdPrevLayer[0], FwdPrevLayer[1], FwdPrevLayer[2], FwdPrevLayer[3], PrevAcY[0], YVec[0], FwdValid);

//        debug.simPrintf(FwdValid, "[%4d] W[%2d][%2d] RdAddr=%2d | Y[0:3][%2d]=(%.12f,%.12f,%.12f,%.12f), Ry[0:3][%2d]=(%.12f,%.12f,%.12f,%.12f), Valid=%d\n", control.count.simpleCounter(32), FwdRowAddr, FwdColAddr, WReadAddr, FwdColAddr, YVec[0], YVec[1], YVec[2], YVec[3], FwdColAddr, RyVec[0], RyVec[1], RyVec[2], RyVec[3], FwdValid);
    }
*/


    // For jUnit Tests
//    debug.simPrintf(FwdValid, "[%4d] W[%2d][%2d] RdAddr=%2d | Y[0:3][%2d]=(%.12f,%.12f,%.12f,%.12f), Ry[0:3][%2d]=(%.12f,%.12f,%.12f,%.12f), Valid=%d\n", control.count.simpleCounter(32), FwdRowAddr, FwdColAddr, WReadAddr, FwdColAddr, YVec[0], YVec[1], YVec[2], YVec[3], FwdColAddr, RyVec[0], RyVec[1], RyVec[2], RyVec[3], FwdValid);



    /////////////////////// Calculation - Backward Propagation ///////////////////////

    // Bypass Prev Y Layer to output
    BwdYVec = BwdPrevLayer;

    // De-Activation
    DFEVector<DFEVar> RGLayer = OutVecType.newInstance(this);
    for (int Y=0; Y<NumOutBlocks; ++Y) {
        switch (AcFunc) {
            case 't': {RGLayer[Y] <== BwdNextRGLayer[Y] * (1-BwdNextLayer[Y]*BwdNextLayer[Y]); break;}
            case 'l': {RGLayer[Y] <== BwdNextRGLayer[Y]; break;}
            default: {throw new IllegalArgumentException("Layer["+ID+"]: Activation Function "+AcFunc+" unsupported.");}    
        }
    }

    // Calculate RGVec when this layer isn't first layer
    if (ID==0) RGVec = constant.vect(NumInBlocks, Def.DataType, 0);
    else {
    
        // TODO: Optimise bit width to avoid overflow
        DFEVector<DFEVar> Temp_RG = InVecType.newInstance(this);
        DFEVector<DFEVar> New_RG  = InVecType.newInstance(this);
        for (int X=0; X<NumInBlocks; ++X) {
            DFEVector<DFEVar> mult_RG = RGLayer * BwdWGridVec[X];
            DFEVar MultAdd_RG = TreeReduce.reduce(new Add<DFEVar>(), mult_RG.getElementsAsList());
            New_RG[X] <== isFirstCol ? MultAdd_RG : MultAdd_RG + Temp_RG[X];
        }    

        // Prepare Write Back Data
        OffsetExpr Offset_RG = stream.makeOffsetAutoLoop("Layer"+ID+"Offset_RG");
        DFEVector<DFEVar> TempWrData_RG = InVecType.newInstance(this);
        for (int X=0; X<NumInBlocks; ++X) {
            TempWrData_RG[X] <== stream.offset(New_RG[X], -Offset_RG);
        }
        DFEVar TempWrAddr_RG = stream.offset(BwdRowAddr, -Offset_RG);
        DFEVar TempWrEn_RG   = stream.offset(BwdRowAddrValid, -Offset_RG);

        // Temp Result of RG
        for (int X=0; X<NumInBlocks; ++X) {
            // Temp RG
            Memory<DFEVar> BRAM_RG = mem.alloc(Def.DataType, InBlockDim);
            Temp_RG[X] <== BRAM_RG.read(BwdRowAddr);
            BRAM_RG.port(TempWrAddr_RG, TempWrData_RG[X], TempWrEn_RG, RamWriteMode.WRITE_FIRST);
        }
        
        // Final Result
        RGVec = New_RG;

        // For Simulation
        // Debug - Checking De-Activation
//        debug.simPrintf(isBwdCalculating & BwdRowAddrValid, "[%4d] W[%2d][%2d] RdAddr=%2d, Buf3RdAddr=%d | RG_3[0:3]=(%f,%f,%f,%f), y_3[0:3]=(%f, %f, %f, %f) | RGLayer[0:3][%2d]=(%f,%f,%f,%f)\n", control.count.simpleCounter(32), BwdRowAddr, BwdColAddr, WPortAddr, BwdNextLayerReadOffsetAddr, BwdNextRGLayer[0], BwdNextRGLayer[1], BwdNextRGLayer[2], BwdNextRGLayer[3], BwdNextLayer[0], BwdNextLayer[1], BwdNextLayer[2], BwdNextLayer[3], BwdColAddr, RGLayer[0], RGLayer[1], RGLayer[2], RGLayer[3]);

        // Debug - Checking RG Calculation - Row[0]Col[:]
//        debug.simPrintf(BwdRowAddrValid, "[%4d] W[0][0:3][%d][%d]=(%.12f, %f, %f, %f), RGLayer[0:3]=(%.12f, %f, %f, %f), Temp_RG[0]=>%.12f | New_RG[0]=%.12f, Valid=%d\n", control.count.simpleCounter(32), BwdRowAddr, BwdColAddr, BwdWGridVec[0][0], BwdWGridVec[0][1], BwdWGridVec[0][2], BwdWGridVec[0][3], RGLayer[0], RGLayer[1], RGLayer[2], RGLayer[3], Temp_RG[0], New_RG[0], BwdValid);

        // Debug - Checking Back Propagation Results
//        debug.simPrintf(BwdValid, "[%4d] RG_%d[0:3]=(%.12f, %.12f, %.12f, %.12f)\n", control.count.simpleCounter(32), constant.var(dfeUInt(2), ID), RGVec[0], RGVec[1], RGVec[2], RGVec[3]);

    }
    
    // Calculate RGW
    // TODO: Optimise bit width to avoid overflow
    OffsetExpr Offset_RGW = stream.makeOffsetAutoLoop("Layer"+ID+"Offset_RGW");
    for (int X=0; X<NumInBlocks; ++X) {
        for (int Y=0; Y<NumOutBlocks; ++Y) {
            DFEVar NewRGW = BwdRGWRdGridVec[X][Y] + BwdPrevLayer[X] * RGLayer[Y];
            BwdRGWWrGridVec[X][Y] <== isInitW ? constant.var(Def.DataType, 0) : stream.offset(NewRGW, -Offset_RGW);
        }
    }
    BwdRGWWrAddr <== isInitW ? InitWPortAddr : stream.offset(RGWReadAddr, -Offset_RGW);
    BwdRGWWrEn   <== isInitW | stream.offset(isRGWUpdating, -Offset_RGW);

    // Calculate RGB
    OffsetExpr Offset_RGB = stream.makeOffsetAutoLoop("Layer"+ID+"Offset_RGB");
    for (int Y=0; Y<NumOutBlocks; ++Y) {
        DFEVar NewRGB = BwdRGBRead[Y] + RGLayer[Y];
        BwdRGBWrite[Y] <== isInitB ? constant.var(Def.DataType, 0) : stream.offset(NewRGB, -Offset_RGB);
    }
    BwdRGBWrAddr <== isInitB ? InitBPortAddr : stream.offset(RGBReadAddr, -Offset_RGB);
    BwdRGBWrEn   <== isInitB | stream.offset(isRGBUpdating, -Offset_RGB);


    // For Simulation
    // Debug - Checking RG Calculation - Row[0]Col[:]
//    debug.simPrintf(isRGWUpdating, "[%4d] PrevLayer[0]=%.12f, RGLayer[0:3]=(%.12f, %.12f, %.12f, %.12f), thisRGW=(%.12f, %.12f, %.12f, %.12f)\n                            OldRGW[%d][0:3][%d][%d]=>(%.12f, %.12f, %.12f, %.12f) | NewRGW=(%.12f, %.12f, %.12f, %.12f), EnWrite=%d\n\n", control.count.simpleCounter(32), BwdPrevLayer[0], RGLayer[0], RGLayer[1], RGLayer[2], RGLayer[3], BwdPrevLayer[0]*RGLayer[0], BwdPrevLayer[0]*RGLayer[1], BwdPrevLayer[0]*RGLayer[2], BwdPrevLayer[0]*RGLayer[3], constant.var(dfeUInt(4), ID), BwdRowAddr, BwdColAddr, BwdRGWRdGridVec[0][0], BwdRGWRdGridVec[0][1], BwdRGWRdGridVec[0][2], BwdRGWRdGridVec[0][3], BwdRGWWrGridVec[0][0], BwdRGWWrGridVec[0][1], BwdRGWWrGridVec[0][2], BwdRGWWrGridVec[0][3], BwdRGWWrEn);





    /*************************************************************************************
    *                                    Read Back                                       *
    *************************************************************************************/



    // RGW Read Back Data
    DFEVector<DFEVar> RGWReadBackVec = InVecType.newInstance(this);
    for (int X=0; X<NumInBlocks; ++X) {
        RGWReadBackVec[X] <== control.mux(RGReadColBaseAddr, BwdRGWRdGridVec[X].getElementsAsList());
    }
    DFEVar RGWReadBackData = control.mux(RGReadRowBaseAddr, RGWReadBackVec.getElementsAsList());

    // RGB Read Back Data
    DFEVar RGBReadBackData = control.mux(RGReadColBaseAddr, BwdRGBRead.getElementsAsList());

    // RG Read Back Data
    RGReadBackData = isReadingBackRGW ? RGWReadBackData : RGBReadBackData;


    // For Simulation
    // Debug - Checking Read Back
//if(ID==2)        debug.simPrintf(isReadingBackRGW, "[%4d] Reading RGW Block X=[%d] Y=[%d], Row=[%d] Col=[%d], BlockAddr=%d, RGW=%.12f\n", control.count.simpleCounter(32), RGReadRowBaseAddr, RGReadColBaseAddr, RGReadRowOffsetAddr, RGReadColOffsetAddr, RGWReadAddr, RGWReadBackData);



	}



    /////////////////////// Activation Functions ///////////////////////

    // tanh() activation function
    // Remarks: temporary workaround: Assign a suitable Data Type to avoid overflow
    // TODO: final solution: use Function Approximation
    private DFEVar tanh(DFEVar x) {
        optimization.pushEnableBitGrowth(true);
        DFEVar exp_2x = KernelMath.exp(2*x);
        DFEVar result = (exp_2x - 1) / (exp_2x + 1);
        optimization.popEnableBitGrowth();
        return result.cast(Def.DataType);
    }


}
