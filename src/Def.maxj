import com.maxeler.maxcompiler.v2.kernelcompiler.KernelLib;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEVar;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEType;
import com.maxeler.maxcompiler.v2.kernelcompiler.types.base.DFEFix.SignMode;
import com.maxeler.maxcompiler.v2.kernelcompiler.stdlib.KernelMath;
import com.maxeler.maxcompiler.v2.utils.Bits;
import java.util.List;
import java.util.ArrayList;


class Def {


    ///////////////////////// TRPO Parameters /////////////////////////

    // Kernel Settings
    public static final int NumLayers     = 4;
    public static final int NumSamples    = 100;
    public static final int BufferDepth   = 2;
    public static final char [] AcFunc    = {'l', 't', 't', 'l'};

//    public static final int  [] LayerSize = { 32, 64, 64, 8};
//    public static final int  [] NumBlocks = {  4,  4,  4, 4};
    public static final int  [] LayerSize = {128, 64, 64, 8};
    public static final int  [] NumBlocks = { 32,  4,  4, 4};
    
//    public static final int  [] LayerSize = {384,128, 64,20};
//    public static final int  [] NumBlocks = { 32,  4,  4, 4};



    ///////////////////////// FPGA Settings /////////////////////////
        
    public static final int KernelFrequencyMAX4 = 150;


    ///////////////////////// Data Types /////////////////////////

    // Input Type
    public static final DFEType InputType = KernelLib.dfeFloat(11, 53);
    
    // Number of Fractional Bits - affects accuracy
    public static final int FracBits = 40;

    // Fix-Point Data Type - 4 Integer Bits, range (-9, 8)
    // Used for Observation, y, Weight, VWeight, Bias, VBias
    public static final DFEType DataType = KernelLib.dfeFix(14, FracBits, SignMode.TWOSCOMPLEMENT);
    
    // Fix-Point Data Type of y and Ry
    public static final DFEType  yType = DataType;
    public static final DFEType RyType = KernelLib.dfeFix(14, FracBits, SignMode.TWOSCOMPLEMENT);
    
    // RG, RGW, RGB, ReadBackType
    public static final DFEType RGType  = KernelLib.dfeFix(14, FracBits, SignMode.TWOSCOMPLEMENT);    
    public static final DFEType RGWType = KernelLib.dfeFix(24, FracBits, SignMode.TWOSCOMPLEMENT);
    public static final DFEType RGBType = KernelLib.dfeFix(24, FracBits, SignMode.TWOSCOMPLEMENT);
    public static final DFEType ReadBackType = KernelLib.dfeFix(24, FracBits, SignMode.TWOSCOMPLEMENT);
    
    // For Accumulator
    public static final DFEType AccType = KernelLib.dfeFix(24, FracBits, SignMode.TWOSCOMPLEMENT);    


    ///////////////////////// Software Utility Functions /////////////////////////

    // Float Input Data Generator
    public static List<Bits> FloatVectorDataGenerator(double [][] data, int numTicks, int VectorWidth) {
        final List<Bits> encodedData = new ArrayList<Bits>(numTicks);
        for (int i=0; i<numTicks; ++i) {
            Bits thisStepBits = InputType.encodeConstant(data[i][0]);
            for (int j=1; j<VectorWidth; ++j){
                thisStepBits = InputType.encodeConstant(data[i][j]).cat(thisStepBits);
            }
            encodedData.add(thisStepBits);
        }
        return encodedData;
    }


    /////////////////////// Activation Functions ///////////////////////

    // tanh() activation function
    // Remarks: temporary workaround: Assign a suitable Data Type to avoid overflow
    // TODO: final solution: use Function Approximation
    public static DFEVar tanh(DFEVar x) {
        x.getKernel().optimization.pushEnableBitGrowth(true);
        DFEVar exp_2x = KernelMath.exp(2*x);
        DFEVar result = 1.0 - 2.0/(exp_2x+1.0);
        x.getKernel().optimization.popEnableBitGrowth();
        return result.cast(Def.DataType);
    }

}
